{"/chapter10":{"title":"部分预渲染（可选）","data":{"":"部分预渲染是在 Next.js 14 中引入的实验性功能。随着该功能在稳定性方面的进展，本页内容可能会进行更新。如果您不喜欢使用实验性功能，您可以跳过这一章节。完成课程不需要学习这一章节。以下是本章中将涵盖的主题：\n部分预渲染是什么。\n部分预渲染是如何工作的。","结合静态和动态内容#结合静态和动态内容":"目前，如果您在路由内调用动态函数（例如 noStore()、cookies() 等），整个路由将变为动态。这与今天大多数 Web 应用程序的构建方式相一致，您可以在整个应用程序或特定路由中选择静态或动态渲染。然而，大多数路由既不是完全静态也不是完全动态。您可能有一个既包含静态又包含动态内容的路由。例如，假设您有一个社交媒体动态，帖子可能是静态的，但帖子的点赞数是动态的。或者是电子商务网站，产品详情是静态的，但用户的购物车是动态的。回到您的 Dashboard 页面，您会考虑哪些组件是静态的，哪些是动态的？一旦准备好，点击下面的按钮，看看我们如何拆分仪表板路由：\n点击展开/折叠\nThe <SideNav> Component doesn't rely on data, and is not personalized to the user, so it can be static.\nThe components in <Page> rely on data that changes often and will be personalized to the user, so they can be dynamic.","部分预渲染是什么#部分预渲染是什么？":"在 Next.js 14 中，有一个名为部分预渲染的新渲染模型的预览。部分预渲染是一项实验性功能，允许您在呈现具有静态加载外壳的路由的同时，保持一些部分是动态的。换句话说，您可以隔离路由的动态部分。例如：当用户访问一个路由时：\n提供一个静态路由外壳，这使得初始加载很快。\n外壳中留下动态内容将异步加载。\n异步洞在并行加载，减少页面的整体加载时间。\n这与您的应用程序今天的行为不同，其中整个路由要么完全是静态的，要么是动态的。部分预渲染将超快的静态边缘交付与完全动态的能力结合在一起，我们相信它有可能成为Web 应用程序的默认渲染模型，将静态站点生成和动态交付的优点融为一体。","部分预渲染是如何工作的#部分预渲染是如何工作的？":"部分预渲染利用 React 的 Concurrent APIs，并使用 Suspense 推迟渲染应用程序的某些部分，直到满足某些条件（例如加载数据）。fallback 被嵌入到初始静态文件中，以及其他静态内容。在构建时（或重新验证期间），路由的静态部分被预渲染，其余部分被推迟到用户请求路由时。值得注意的是，将组件包装在 Suspense 中并不会使组件本身变为动态的（请记住使用 unstable_noStore 来实现此行为），而是 Suspense 用作路由的静态和动态部分之间的边界。部分预渲染的好处在于，您无需更改代码即可使用它。只要使用 Suspense 包装路由的动态部分，Next.js 就会知道路由的哪些部分是静态的，哪些是动态的。\n注意：要了解有关如何配置部分预渲染的详细信息，请查阅部分预渲染（实验性）文档或尝试使用部分预渲染模板和演示。重要的是要注意，该功能目前处于实验性阶段，尚未准备好用于生产部署。","总结#总结":"回顾一下，您已经采取了一些优化应用程序数据获取的步骤，您已经：\n在与应用程序代码相同的地区创建了一个数据库，以减少服务器和数据库之间的延迟。\n在服务器上使用 React 服务器组件获取数据。这允许您将昂贵的数据获取和逻辑保留在服务器上，减少客户端 JavaScript 捆绑，并防止数据库机密信息暴露给客户端。\n使用 SQL 仅获取所需的数据，减少每个请求传输的数据量和内存中转换数据所需的 JavaScript 量。\n在 JavaScript 中并行获取数据（在有意义的情况下）。\n实施了流式传输以防止慢速数据请求阻塞整个页面，并允许用户在等待所有内容加载完成之前开始与 UI 进行交互。\n将数据获取移动到需要它的组件，从而隔离了路由中应该是动态的部分，为部分预渲染做好准备。\n在下一章中，我们将研究在获取数据时您可能需要实现的两种常见模式：搜索和分页。"}},"/chapter1":{"title":"入门","data":{"创建新项目#创建新项目":"要创建一个 Next.js 应用程序，请打开终端，进入您想要存储项目的文件夹，并运行以下命令：\nnpx create-next-app@latest nextjs-dashboard --use-npm --example \"https://github.com/vercel/next-learn/tree/main/dashboard/starter-example\"\n该命令使用 create-next-app，这是一个命令行接口（CLI）工具，可以为您设置一个 Next.js 应用程序。在上述命令中，您还使用 --example 标志与此课程的入门 示例 一起使用。","浏览项目#浏览项目":"与让您从头编写代码的教程不同，这门课程的大部分代码已经为您编写了。这更好地反映了现实世界的开发，您可能会与现有的代码库一起工作。我们的目标是帮助您专注于学习 Next.js 的主要特性，而无需编写所有应用程序代码。安装后，在代码编辑器中打开项目并导航到 nextjs-dashboard。让我们花些时间来探索项目。","文件夹结构#文件夹结构":"您会注意到项目具有以下文件夹结构：\n/app：包含应用程序的所有路由、组件和逻辑，这是您将主要从中工作的地方。\n/app/lib：包含在应用程序中使用的函数，例如可重用的实用函数和数据获取函数。\n/app/ui：包含应用程序的所有 UI 组件，例如卡片、表格和表单。为节省时间，我们已经为您预先样式化了这些组件。\n/public：包含应用程序的所有静态资产，例如图片。\n/script/：包含一个 seeding（这里翻译为 “播种” 可以理解为数据库的 Migration）脚本，您将在后面的章节中使用它来填充您的数据库。\n配置文件：您还会注意到应用程序根目录下有一些配置文件，例如 next.config.js。大多数这些文件在使用 `create-next-app`` 启动新项目时会被创建和预配置。在本课程中，您不需要修改它们。\n随意探索这些文件夹，如果您还不理解代码正在执行的一切，不用担心。","placeholder-data占位数据#Placeholder data（占位数据）":"在构建用户界面时，使用一些占位数据很有帮助。如果尚未提供数据库或 API，您可以：\n使用 JSON 格式的占位数据或作为 JavaScript 对象。\n使用第三方服务，如 mockAPI。\n对于此项目，我们在 app/lib/placeholder-data.js 中提供了一些占位数据。文件中的每个 JavaScript 对象代表数据库中的一张表。例如，对于发票表：\nconst invoices = [\r\n  {\r\n    customer_id: customers[0].id,\r\n    amount: 15795,\r\n    status: 'pending',\r\n    date: '2022-12-06',\r\n  },\r\n  {\r\n    customer_id: customers[1].id,\r\n    amount: 20348,\r\n    status: 'pending',\r\n    date: '2022-11-14',\r\n  },\r\n  // ...\r\n];\n在设置数据库的章节中，您将使用这些数据来填充数据库（用一些初始数据填充它）。","typescript#TypeScript":"您可能还注意到大多数文件都带有 .ts 或 .tsx 后缀。这是因为该项目是使用 TypeScript 编写的。我们希望创建一个反映现代 web 环境的课程。如果您不熟悉 TypeScript，没关系 - 在需要时，我们将提供 TypeScript 代码片段。现在，请查看 /app/lib/definitions.ts 文件。在这里，我们手动定义了将从数据库返回的类型。例如，发票表具有以下类型：\nexport type Invoice = {\r\n  id: string;\r\n  customer_id: string;\r\n  amount: number;\r\n  date: string;\r\n  // In TypeScript, this is called a string union type.\r\n  // It means that the \"status\" property can only be one of the two strings: 'pending' or 'paid'.\r\n  status: 'pending' | 'paid';\r\n};\n通过使用 TypeScript，您可以确保不会意外地将错误的数据格式传递给组件或数据库，比如将 number 类型传递给发票 amount 属性而不是 string 类型。如果您是 TypeScript 开发者：\n我们手动声明数据类型，但为了更好的类型安全性，我们建议使用 Prisma，它会根据数据库架构自动生成类型。\nNext.js 会检测到您的项目使用 TypeScript，并自动安装必要的软件包和配置。Next.js 还为您的代码编辑器提供了一个 TypeScript 插件，以帮助自动完成和提供类型安全性。","运行开发服务器#运行开发服务器":"运行 npm i 来安装项目的软件包。\nnpm i\n然后运行 npm run dev 来启动开发服务器。\nnpm run dev\nnpm run dev 会在端口 3000 上启动您的 Next.js 开发服务器。让我们检查一下它是否工作。在浏览器中打开 http://localhost:3000。您的首页应该如下所示："}},"/chapter12":{"title":"Mutating 数据","data":{"":"在上一章节中，使用 URL 搜索参数和 Next.js API 实现了搜索和分页。让我们继续在发票（Invoices）页面上工作，添加创建、更新和删除发票的功能！以下是本章中将涵盖的主题：\nReact Server Actions 是什么以及如何使用它们来改变数据。\n如何处理表单和 Server Components。\n使用原生 formData 对象的最佳实践，包括类型验证。\n如何使用 revalidatePath API 重新验证客户端缓存。\n如何创建具有特定 IDs 的动态路由段。\n如何使用 React 的 useFormStatus hook 进行乐观更新。","什么是-server-actions#什么是 Server Actions？":"React Server Actions 允许您在服务器上直接运行异步代码。它们消除了通过创建 API 改变数据的方式。相反，您编写的在服务器上执行的异步函数，可以在客户端或 Server Components 中直接调用。对于 Web 应用程序安全性是最重要的，因为它们可能受到各种威胁。这就是 Server Actions 发挥作用的地方。它们提供了一种有效的安全解决方案，防范各种类型的攻击，保护您的数据，并确保访问是经过授权的。Server Actions 通过诸如 POST 请求、加密闭包、严格的输入检查、错误消息 hashing 和主机限制等技术实现这一点，所有这些技术共同作用以显着增强应用程序的安全性。","server-actions-和-forms#Server Actions 和 forms":"在 React 中，您可以在 <form> 元素中使用 action 属性来调用操作。该操作将自动接收包含捕获数据的原生 FormData 对象。例如：\n// Server Component\r\nexport default function Page() {\r\n  // Action\r\n  async function create(formData: FormData) {\r\n    'use server';\r\n \r\n    // Logic to mutate data...\r\n  }\r\n \r\n  // Invoke the action using the \"action\" attribute\r\n  return <form action={create}>...</form>;\r\n}\n在 Server Component 中调用 Server Action 的一个优势是渐进增强 - 即使客户端上禁用了 JavaScript，forms 仍可以工作。","nextjs-with-server-actions#Next.js with Server Actions":"Server Actions 与 Next.js 缓存深度集成。通过 Server Action 提交表单时，您不仅可以使用该操作来改变数据，还可以使用 revalidatePath 和 revalidateTag 等 API 来重新验证相关的缓存。\n让我们看看它是如何协同工作的！","创建发票#创建发票":"以下是创建一个新发票的步骤：\n创建一个捕获用户输入的 form。\n创建一个 Server Action，并从 form 中调用它。\n在 Server Action 中，从 formData 对象中提取数据。\n验证和准备要插入数据库的数据。\n插入数据并处理任何错误。\n重新验证缓存并将用户重定向回发票页面。","1-创建新-route-和-form#1. 创建新 route 和 form":"首先，在 /invoices 目录内，添加一个名为 /create 的新路由段，包含一个 page.tsx 文件：您将使用此路由来创建新的发票。在您的 page.tsx 文件中，粘贴以下代码，然后花些时间研究它：\nimport Form from '@/app/ui/invoices/create-form';\r\nimport Breadcrumbs from '@/app/ui/invoices/breadcrumbs';\r\nimport { fetchCustomers } from '@/app/lib/data';\r\n \r\nexport default async function Page() {\r\n  const customers = await fetchCustomers();\r\n \r\n  return (\r\n    <main>\r\n      <Breadcrumbs\r\n        breadcrumbs={[\r\n          { label: 'Invoices', href: '/dashboard/invoices' },\r\n          {\r\n            label: 'Create Invoice',\r\n            href: '/dashboard/invoices/create',\r\n            active: true,\r\n          },\r\n        ]}\r\n      />\r\n      <Form customers={customers} />\r\n    </main>\r\n  );\r\n}\n您的页面是一个 Server Component，用于获取 customers 并将其传递给 <Form> 组件。为了节省时间，我们已经为您创建了 <Form> 组件。转到 <Form> 组件，您会看到该表单：\n有一个包含 customers 列表的 <select>（下拉）元素。\n有一个用于 amount 的带有 type=\"number\" 的 <input> 元素。\n有两个带有 type=\"radio\" 的 <input> 元素，用于状态。\n有一个 type=\"submit\" 的按钮。\n在 http://localhost:3000/dashboard/invoices/create 上，您应该看到以下 UI：","2-创建-server-action#2. 创建 Server Action":"太好了，现在让我们创建一个 Server Action，当 form 提交时将调用该 Server Action。导航到您的 lib 目录并创建一个名为 actions.ts 的新文件。在该文件顶部添加 React 的 · 指令：\n'use server';\n通过添加 'use server'，您将文件中的所有导出函数标记为服务器函数。然后可以将这些服务器函数导入到 Client 和 Server 组件中，使它们变得非常灵活。您还可以通过在 action 内部添加 \"use server\" 直接在 Server Component 中编写 Server Actions。但是在本课程中，我们将把它们都组织在一个单独的文件中。在您的 actions.ts 文件中，创建一个接受 formData 的新异步函数：\n'use server';\r\n \r\nexport async function createInvoice(formData: FormData) {}\n然后，在您的 <Form> 组件中，从 actions.ts 文件中导入 createInvoice。给 <form> 元素添加 action 属性，并调用 createInvoice action。\n'use client';\r\n \r\nimport { customerField } from '@/app/lib/definitions';\r\nimport Link from 'next/link';\r\nimport {\r\n  CheckIcon,\r\n  ClockIcon,\r\n  CurrencyDollarIcon,\r\n  UserCircleIcon,\r\n} from '@heroicons/react/24/outline';\r\nimport { Button } from '@/app/ui/button';\r\nimport { createInvoice } from '@/app/lib/actions';\r\n \r\nexport default function Form({\r\n  customers,\r\n}: {\r\n  customers: customerField[];\r\n}) {\r\n  return (\r\n    <form action={createInvoice}>\r\n      // ...\r\n  )\r\n}\n值得知道：在 HTML 中，您会将 URL 传递给 action 属性。此 URL 将是您的 form 数据应提交的目标（通常是 API 端点）。\n然而，在 React 中，action 属性被视为一个特殊的 prop - 这意味着 React 在其之上构建，以允许调用 actions。\n在幕后，Server Actions 创建一个 POST API 端点。这就是在使用 Server Actions 时为什么不需要手动创建 API 端点的原因。","3-从-formdata-中提取数据#3. 从 formData 中提取数据":"回到您的 actions.ts 文件，您需要提取 formData 的值，有几种方法可以使用。在本例中，让我们使用 .get(name) 方法。\n'use server';\r\n \r\nexport async function createInvoice(formData: FormData) {\r\n  const rawFormData = {\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  };\r\n  // Test it out:\r\n  console.log(rawFormData);\r\n}\n提示：如果您正在处理包含许多字段的 forms，您可能想考虑使用 JavaScript 的 Object.fromEntries() 方法与 entries() 方法。例如：\nconst rawFormData = Object.fromEntries(formData.entries())\n为了检查一切是否连接正确，尝试填写 form。提交后，您应该在终端中看到您刚刚输入到 forms 中的数据。现在，您的数据呈对象形式，将更容易处理。","4-验证和准备数据#4. 验证和准备数据":"在将 form 数据发送到数据库之前，您希望确保它具有正确的格式和正确的类型。如果您还记得在本课程前面的部分，您的 invoices 表期望以下格式的数据：\nexport type Invoice = {\r\n  id: string; // Will be created on the database\r\n  customer_id: string;\r\n  amount: number; // Stored in cents\r\n  status: 'pending' | 'paid';\r\n  date: string;\r\n};\n到目前为止，您只有来自 form 的 customer_id、amount 和 status。类型验证和强制转换验证来自 form 的数据是否符合数据库中期望的类型非常重要。例如，如果您在 action 中添加一个 console.log：\nconsole.log(typeof rawFormData.amount);\n您会注意到 amount 是字符串类型，而不是数字。这是因为具有 type=\"number\" 的输入元素实际上返回一个字符串，而不是数字！为了处理类型验证，您有几个选择。虽然您可以手动验证类型，但使用类型验证库可以为您节省时间和精力。对于您的示例，我们将使用 Zod，这是一个 TypeScript 优先的验证库，可以为你简化这些校验任务。在您的 actions.ts 文件中，导入 Zod 并定义一个与 form 对象形状匹配的 schema。这个 schema 将在 formData 保存到数据库之前验证它。\n'use server';\r\n \r\nimport { z } from 'zod';\r\n \r\nconst FormSchema = z.object({\r\n  id: z.string(),\r\n  customerId: z.string(),\r\n  amount: z.coerce.number(),\r\n  status: z.enum(['pending', 'paid']),\r\n  date: z.string(),\r\n});\r\n \r\nconst CreateInvoice = FormSchema.omit({ id: true, date: true });\r\n \r\nexport async function createInvoice(formData: FormData) {\r\n  // ...\r\n}\namount 字段被专门设置为强制（更改）从字符串更改为数字，同时还验证其类型。然后，您可以将 rawFormData 传递给 CreateInvoice 以验证类型：\n// ...\r\nexport async function createInvoice(formData: FormData) {\r\n  const { customerId, amount, status } = CreateInvoice.parse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n}\n以分为单位存储值通常，将货币值以分为单位存储在数据库中是一种良好的做法，以消除 JavaScript 浮点错误并确保更高的准确性。让我们将金额转换为分：\n// ...\r\nexport async function createInvoice(formData: FormData) {\r\n  const { customerId, amount, status } = CreateInvoice.parse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n  const amountInCents = amount * 100;\r\n}\n创建新日期最后，让我们为发票的创建日期创建一个新的格式为 \"YYYY-MM-DD\" 的日期：\n// ...\r\nexport async function createInvoice(formData: FormData) {\r\n  const { customerId, amount, status } = CreateInvoice.parse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n  const amountInCents = amount * 100;\r\n  const date = new Date().toISOString().split('T')[0];\r\n}","5-插入数据到数据库#5. 插入数据到数据库":"现在您已经拥有数据库所需的所有值，您可以创建一个 SQL 查询，将新发票插入数据库并传入变量：\nimport { z } from 'zod';\r\nimport { sql } from '@vercel/postgres'; // 这里需要注意\r\n \r\n// ...\r\n \r\nexport async function createInvoice(formData: FormData) {\r\n  const { customerId, amount, status } = CreateInvoice.parse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n  const amountInCents = amount * 100;\r\n  const date = new Date().toISOString().split('T')[0];\r\n \r\n  await sql`\r\n    INSERT INTO invoices (customer_id, amount, status, date)\r\n    VALUES (${customerId}, ${amountInCents}, ${status}, ${date})\r\n  `;\r\n}\n译者注：因为 Vercel Postgres 搭配本地数据库还存在一些问题，在 nextjs-learn-example 示例中，我使用了一种 hack 的方式来处理，如果您在本地开发是按照我的 hack 方式，请替换 import { sql } from '@vercel/postgres'; 为 import { sql } from './sql-hack'; 详情参见 https://qufei1993.github.io/nextjs-learn-cn/chapter17\n现在，我们还没有处理任何错误。我们将在下一章中处理错误。让我们继续进行下一步。","6-重新验证和重定向#6. 重新验证和重定向":"Next.js 拥有一个客户端路由缓存，它在用户的浏览器中存储路由段一段时间。除了prefetching，此缓存确保用户在路由之间快速导航的同时减少向服务器发出的请求次数。由于您正在更新发票路由中显示的数据，因此您希望清除此缓存并触发对服务器的新请求。您可以使用 Next.js 的 revalidatePath 函数来实现：\n'use server';\r\n \r\nimport { z } from 'zod';\r\nimport { sql } from '@vercel/postgres';\r\nimport { revalidatePath } from 'next/cache';\r\n \r\n// ...\r\n \r\nexport async function createInvoice(formData: FormData) {\r\n  const { customerId, amount, status } = CreateInvoice.parse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n  const amountInCents = amount * 100;\r\n  const date = new Date().toISOString().split('T')[0];\r\n \r\n  await sql`\r\n    INSERT INTO invoices (customer_id, amount, status, date)\r\n    VALUES (${customerId}, ${amountInCents}, ${status}, ${date})\r\n  `;\r\n \r\n  revalidatePath('/dashboard/invoices');\r\n}\n一旦数据库已更新，将重新验证 /dashboard/invoices 路径，并从服务器获取新数据。此时，您还希望将用户重定向回 /dashboard/invoices 页面。您可以使用 Next.js 的 [redirect](https://nextjs.org/docs/app/api-reference/functions/redirect) 函数来实现：\n'use server';\r\n \r\nimport { z } from 'zod';\r\nimport { sql } from '@vercel/postgres';\r\nimport { revalidatePath } from 'next/cache';\r\nimport { redirect } from 'next/navigation';\r\n \r\n// ...\r\n \r\nexport async function createInvoice(formData: FormData) {\r\n  // ...\r\n \r\n  revalidatePath('/dashboard/invoices');\r\n  redirect('/dashboard/invoices');\r\n}\n恭喜！您刚刚实现了您的第一个 Server Action。通过添加一个新的发票来测试它，如果一切正常：\n在提交时，您应该被重定向到 /dashboard/invoices 路由。\n您应该看到新发票在表格的顶部。","更新发票#更新发票":"更新发票 form 同创建发票 form 类似，唯一区别是你需要传递发票 id 来更新数据库中的记录。让我们看看如何获取并传递发票 id。以下是更新发票的步骤：\n创建一个带有发票 id 的新动态路由段。\n从页面参数中读取发票 id。\n从数据库中获取特定发票。\n使用发票数据预填充 form。\n更新数据库中的发票数据。","1-创建带有发票-id-的动态路由段#1. 创建带有发票 id 的动态路由段":"Next.js 允许您在不知道确切段名称的情况下创建动态路由段，并希望基于数据创建路由。这可以是博客文章标题、产品页面等。您可以通过将文件夹名称包装在方括号中来创建动态路由段。例如，[id]、[post] 或 [slug]。在 /invoices 文件夹中，创建一个名为 [id] 的新动态路由，然后创建一个名为 edit 的新路由，其中包含一个 page.tsx 文件。您的文件结构应如下所示：在您的 <Table> 组件中，请注意有一个 <UpdateInvoice /> 按钮，它从表记录中接收发票的 id。\nexport default async function InvoicesTable({\r\n  query,\r\n  currentPage,\r\n}: {\r\n  query: string;\r\n  currentPage: number;\r\n}) {\r\n  return (\r\n    // ...\r\n    <td className=\"flex justify-end gap-2 whitespace-nowrap px-6 py-4 text-sm\">\r\n      <UpdateInvoice id={invoice.id} />\r\n      <DeleteInvoice id={invoice.id} />\r\n    </td>\r\n    // ...\r\n  );\r\n}\n导航到您的 <UpdateInvoice /> 组件，并更新 Link 的 href 以接收 id 属性。您可以使用模板文字链接到动态路由段：\nimport { PencilIcon, PlusIcon, TrashIcon } from '@heroicons/react/24/outline';\r\nimport Link from 'next/link';\r\n \r\n// ...\r\n \r\nexport function UpdateInvoice({ id }: { id: string }) {\r\n  return (\r\n    <Link\r\n      href={`/dashboard/invoices/${id}/edit`}\r\n      className=\"rounded-md border p-2 hover:bg-gray-100\"\r\n    >\r\n      <PencilIcon className=\"w-5\" />\r\n    </Link>\r\n  );\r\n}","2-从页面参数中读取发票-id#2. 从页面参数中读取发票 id":"回到您的 <Page> 组件，粘贴以下代码：\nimport Form from '@/app/ui/invoices/edit-form';\r\nimport Breadcrumbs from '@/app/ui/invoices/breadcrumbs';\r\nimport { fetchCustomers } from '@/app/lib/data';\r\n \r\nexport default async function Page() {\r\n  return (\r\n    <main>\r\n      <Breadcrumbs\r\n        breadcrumbs={[\r\n          { label: 'Invoices', href: '/dashboard/invoices' },\r\n          {\r\n            label: 'Edit Invoice',\r\n            href: `/dashboard/invoices/${id}/edit`,\r\n            active: true,\r\n          },\r\n        ]}\r\n      />\r\n      <Form invoice={invoice} customers={customers} />\r\n    </main>\r\n  );\r\n}\n请注意，它与您的 /create 发票页面类似，只是导入了不同的 form（来自 edit-form.tsx 文件）。该 form 应该使用客户的名称、发票金额和状态的 defaultValue 进行预填充。要预填充 form 字段，您需要使用 id 获取特定的发票。除了 searchParams 之外，页面组件还接收一个称为 params 的属性，您可以使用它来访问 id。更新您的 <Page> 组件以接收此属性：\nimport Form from '@/app/ui/invoices/edit-form';\r\nimport Breadcrumbs from '@/app/ui/invoices/breadcrumbs';\r\nimport { fetchCustomers } from '@/app/lib/data';\r\n \r\nexport default async function Page({ params }: { params: { id: string } }) {\r\n  const id = params.id;\r\n  // ...\r\n}","3-获取特定发票#3. 获取特定发票":"然后：\n导入一个名为 fetchInvoiceById 的新函数，并将 id 作为参数传递。\n导入 fetchCustomers 以获取下拉列表的客户名称。\n您可以使用 Promise.all 并行获取发票和客户：\nimport Form from '@/app/ui/invoices/edit-form';\r\nimport Breadcrumbs from '@/app/ui/invoices/breadcrumbs';\r\nimport { fetchInvoiceById, fetchCustomers } from '@/app/lib/data';\r\n \r\nexport default async function Page({ params }: { params: { id: string } }) {\r\n  const id = params.id;\r\n  const [invoice, customers] = await Promise.all([\r\n    fetchInvoiceById(id),\r\n    fetchCustomers(),\r\n  ]);\r\n  // ...\r\n}\n您将在终端中看到有关 invoice 属性的临时 TS 错误，因为 invoice 可能是 undefined。现在不要担心，当您添加错误处理时，将在下一章中解决它。太好了！现在，测试一切是否连接正确。访问 http://localhost:3000/dashboard/invoices 然后单击铅笔图标以编辑发票。导航后，您应该看到一个预填充有发票详细信息的 form：URL 也应更新为带有 id 的形式：http://localhost:3000/dashboard/invoice/uuid/edit\nUUID VS 自增键\r\n我们使用 UUID 而不是自增键（例如 1、2、3 等）。这会使 URL 变得更长；然而，UUID 消除了 ID 冲突的风险，是全球唯一的，并减少了枚举攻击的风险 - 这使它们非常适用于大型数据库。\n然而，如果您喜欢更清晰的 URL，您可能更喜欢使用自增键。","4-将-id-传递给-server-action#4. 将 id 传递给 Server Action":"最后，您希望将 id 传递给 Server Action，以便您可以在数据库中更新正确的记录。您不能像这样将 id 作为参数传递：\n// Passing an id as argument won't work\r\n<form action={updateInvoice(id)}>\n反而，您可以使用 JS bind 将 id 传递给 Server Action。这将确保传递给 Server Action 的任何值都被编码。\n// ...\r\nimport { updateInvoice } from '@/app/lib/actions';\r\n \r\nexport default function EditInvoiceForm({\r\n  invoice,\r\n  customers,\r\n}: {\r\n  invoice: InvoiceForm;\r\n  customers: CustomerField[];\r\n}) {\r\n  const updateInvoiceWithId = updateInvoice.bind(null, invoice.id);\r\n \r\n  return (\r\n    <form action={updateInvoiceWithId}>\r\n      <input type=\"hidden\" name=\"id\" value={invoice.id} />\r\n    </form>\r\n  );\r\n}\n注意：在 form 中使用隐藏的 input 字段也是可行的（例如 <input type=\"hidden\" name=\"id\" value={invoice.id} />）。然而，这些值将以完整文本形式出现在 HTML 源代码中，对于 id 等敏感数据来说并不理想。然后，在您的 actions.ts 文件中，创建一个新的 action updateInvoice：\n// Use Zod to update the expected types\r\nconst UpdateInvoice = FormSchema.omit({ id: true, date: true });\r\n \r\n// ...\r\n \r\nexport async function updateInvoice(id: string, formData: FormData) {\r\n  const { customerId, amount, status } = UpdateInvoice.parse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n \r\n  const amountInCents = amount * 100;\r\n \r\n  await sql`\r\n    UPDATE invoices\r\n    SET customer_id = ${customerId}, amount = ${amountInCents}, status = ${status}\r\n    WHERE id = ${id}\r\n  `;\r\n \r\n  revalidatePath('/dashboard/invoices');\r\n  redirect('/dashboard/invoices');\r\n}\n与 createInvoice action 类似，在这里您正在：\n从 formData 中提取数据。\n使用 Zod 验证类型。\n将金额转换为分。\n将变量传递给 SQL 查询。\n调用 revalidatePath 以清除客户端缓存并发出新的服务器请求。\n调用 redirect 将用户重定向到发票页面。\n通过编辑发票进行测试。提交 form 后，您应该被重定向到发票页面，并且发票应该已更新。","删除发票#删除发票":"要使用 Server Action 删除发票，请将删除按钮包装在 <form> 元素中，并使用 bind 将 id 传递给 Server Action：\nimport { deleteInvoice } from '@/app/lib/actions';\r\n \r\n// ...\r\n \r\nexport function DeleteInvoice({ id }: { id: string }) {\r\n  const deleteInvoiceWithId = deleteInvoice.bind(null, id);\r\n \r\n  return (\r\n    <form action={deleteInvoiceWithId}>\r\n      <button className=\"rounded-md border p-2 hover:bg-gray-100\">\r\n        <span className=\"sr-only\">Delete</span>\r\n        <TrashIcon className=\"w-4\" />\r\n      </button>\r\n    </form>\r\n  );\r\n}\n在您的 actions.ts 文件中，创建一个名为 deleteInvoice 的新 action。\nexport async function deleteInvoice(id: string) {\r\n  await sql`DELETE FROM invoices WHERE id = ${id}`;\r\n  revalidatePath('/dashboard/invoices');\r\n}\n由于此 action 是在 /dashboard/invoices 路径中调用的，您不需要调用 redirect。调用 revalidatePath 将触发新的服务器请求并重新渲染表格。","进一步阅读#进一步阅读":"在本章中，您学习了如何使用 Server Actions 来改变数据。您还学会了如何使用 revalidatePath API 来重新验证Next.js 缓存，并使用 redirect 将用户重定向到新页面。您还可以阅读更多关于使用 Server Actions 进行安全性方面的内容，以获取更多学习资料。"}},"/chapter13":{"title":"错误处理","data":{"":"在上一章节中，您学到了如何使用 Server Actions 来改变数据。让我们看看如何使用 JavaScript 的 try/catch 语句和 Next.js API 优雅地处理错误。以下是本章中将涵盖的主题：\n如何使用特殊的 error.tsx 文件捕获路由段中的错误，并向用户显示一个备用 UI。\n如何使用 notFound 函数和 not-found 文件来处理 404 错误（对于不存在的资源）。","为-server-actions-添加-trycatch#为 Server Actions 添加 try/catch":"首先，让我们向您的 Server Actions 添加 JavaScript 的 try/catch 语句，以使您能够优雅地处理错误。如果您知道如何操作，请花费几分钟更新您的 Server Actions，或者您可以复制下面的代码：\n点击展开/折叠\nexport async function createInvoice(formData: FormData) {\r\n  const { customerId, amount, status } = CreateInvoice.parse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n\r\n  const amountInCents = amount * 100;\r\n  const date = new Date().toISOString().split('T')[0];\r\n\r\n  try {\r\n    await sql`\r\n      INSERT INTO invoices (customer_id, amount, status, date)\r\n      VALUES (${customerId}, ${amountInCents}, ${status}, ${date})\r\n    `;\r\n  } catch (error) {\r\n    return {\r\n      message: 'Database Error: Failed to Create Invoice.',\r\n    };\r\n  }\r\n\r\n  revalidatePath('/dashboard/invoices');\r\n  redirect('/dashboard/invoices');\r\n}\n点击展开/折叠\nexport async function updateInvoice(id: string, formData: FormData) {\r\n  const { customerId, amount, status } = UpdateInvoice.parse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n\r\n  const amountInCents = amount * 100;\r\n\r\n  try {\r\n    await sql`\r\n        UPDATE invoices\r\n        SET customer_id = ${customerId}, amount = ${amountInCents}, status = ${status}\r\n        WHERE id = ${id}\r\n      `;\r\n  } catch (error) {\r\n    return { message: 'Database Error: Failed to Update Invoice.' };\r\n  }\r\n\r\n  revalidatePath('/dashboard/invoices');\r\n  redirect('/dashboard/invoices');\r\n}\n点击展开/折叠\nexport async function deleteInvoice(id: string) {\r\n  try {\r\n    await sql`DELETE FROM invoices WHERE id = ${id}`;\r\n    revalidatePath('/dashboard/invoices');\r\n    return { message: 'Deleted Invoice.' };\r\n  } catch (error) {\r\n    return { message: 'Database Error: Failed to Delete Invoice.' };\r\n  }\r\n}\n注意，redirect 是在 try/catch 块之外调用的。这是因为 redirect 的工作方式是通过抛出一个错误，该错误会被 catch 块捕获。为了避免这种情况，您可以在 try/catch 之后调用 redirect。redirect 只有在 try 成功的情况下才会被执行。现在，让我们看一下在 Server Action 中抛出错误时会发生什么。您可以更早的抛出一个错误。例如，在 deleteInvoice 操作中，在函数的最上面抛出一个错误：\nexport async function deleteInvoice(id: string) {\r\n  throw new Error('Failed to Delete Invoice');\r\n \r\n  // Unreachable code block\r\n  try {\r\n    await sql`DELETE FROM invoices WHERE id = ${id}`;\r\n    revalidatePath('/dashboard/invoices');\r\n    return { message: 'Deleted Invoice' };\r\n  } catch (error) {\r\n    return { message: 'Database Error: Failed to Delete Invoice' };\r\n  }\r\n}\n当您尝试删除发票时，您应该在本机上看到一个错误。在开发过程中看到这些错误非常有帮助，因为它可以让您尽早捕获任何潜在的问题。然而，您还希望向用户显示错误，以避免突然的故障并允许您的应用程序继续运行。这就是 Next.js 的 error.tsx 文件发挥作用的地方。","使用-errortsx-处理全局错误#使用 error.tsx 处理全局错误":"error.tsx 文件可用于为路由段定义 UI 边界。它用作意外错误的综合处理并允许您向用户显示备用 UI。在您的 /dashboard/invoices 文件夹内，创建一个名为 error.tsx 的新文件并粘贴以下代码：\n'use client';\r\n \r\nimport { useEffect } from 'react';\r\n \r\nexport default function Error({\r\n  error,\r\n  reset,\r\n}: {\r\n  error: Error & { digest?: string };\r\n  reset: () => void;\r\n}) {\r\n  useEffect(() => {\r\n    // Optionally log the error to an error reporting service\r\n    console.error(error);\r\n  }, [error]);\r\n \r\n  return (\r\n    <main className=\"flex h-full flex-col items-center justify-center\">\r\n      <h2 className=\"text-center\">Something went wrong!</h2>\r\n      <button\r\n        className=\"mt-4 rounded-md bg-blue-500 px-4 py-2 text-sm text-white transition-colors hover:bg-blue-400\"\r\n        onClick={\r\n          // Attempt to recover by trying to re-render the invoices route\r\n          () => reset()\r\n        }\r\n      >\r\n        Try again\r\n      </button>\r\n    </main>\r\n  );\r\n}\n以上面代码有几个要点你需要注意：\n\"use client\" - error.tsx 需要是一个客户端组件（Client Component）。\n它接受两个参数：\nerror：这个对象是 JavaScript 原生 Error 对象的一个实例。\nreset：这是一个重置错误边界的函数。当执行时，该函数将尝试重新渲染路由段。\n当您再次尝试删除发票时，应该会看到以下 UI：","使用-notfound-函数处理-404-错误#使用 notFound 函数处理 404 错误":"另一种优雅处理错误的方式是使用 notFound 函数。虽然 error.tsx 对于捕获全局错误很有用，但在尝试获取不存在的资源时，可以使用 notFound。例如，访问 http://localhost:3000/dashboard/invoices/2e94d1ed-d220-449f-9f11-f0bbceed9645/edit。这是一个不存在于您的数据库中的虚假 UUID。您将立即看到 error.tsx 启动，因为这是 /invoices 的子路由，其中定义了 error.tsx。然而，如果您想更具体，可以显示一个 404 错误，告诉用户他们尝试访问的资源未被找到。您可以通过进入 data.ts 中的 fetchInvoiceById 函数，并在控制台记录返回的发票来确认资源不存在：\nexport async function fetchInvoiceById(id: string) {\r\n  noStore();\r\n  try {\r\n    // ...\r\n \r\n    console.log(invoice); // Invoice is an empty array []\r\n    return invoice[0];\r\n  } catch (error) {\r\n    console.error('Database Error:', error);\r\n    throw new Error('Failed to fetch invoice.');\r\n  }\r\n}\n现在您知道发票在数据库中不存在，让我们使用 notFound 来处理它。导航到 /dashboard/invoices/[id]/edit/page.tsx，并从 'next/navigation' 导入 { notFound }。然后，您可以使用条件语句在发票不存在时调用 notFound：\nimport { fetchInvoiceById, fetchCustomers } from '@/app/lib/data';\r\nimport { updateInvoice } from '@/app/lib/actions';\r\nimport { notFound } from 'next/navigation';\r\n \r\nexport default async function Page({ params }: { params: { id: string } }) {\r\n  const id = params.id;\r\n  const [invoice, customers] = await Promise.all([\r\n    fetchInvoiceById(id),\r\n    fetchCustomers(),\r\n  ]);\r\n \r\n  if (!invoice) {\r\n    notFound();\r\n  }\r\n \r\n  // ...\r\n}\n完美！如果找不到特定的发票，<Page> 现在会抛出一个错误。为了向用户显示错误 UI，请在 /edit 文件夹内创建一个 not-found.tsx 文件。然后，在 not-found.tsx 文件中，粘贴以下代码：\nimport Link from 'next/link';\r\nimport { FaceFrownIcon } from '@heroicons/react/24/outline';\r\n \r\nexport default function NotFound() {\r\n  return (\r\n    <main className=\"flex h-full flex-col items-center justify-center gap-2\">\r\n      <FaceFrownIcon className=\"w-10 text-gray-400\" />\r\n      <h2 className=\"text-xl font-semibold\">404 Not Found</h2>\r\n      <p>Could not find the requested invoice.</p>\r\n      <Link\r\n        href=\"/dashboard/invoices\"\r\n        className=\"mt-4 rounded-md bg-blue-500 px-4 py-2 text-sm text-white transition-colors hover:bg-blue-400\"\r\n      >\r\n        Go Back\r\n      </Link>\r\n    </main>\r\n  );\r\n}\n刷新路由，现在您应该看到以下 UI：这是要记住的事情，notFound 会优先于 error.tsx，因此当您想处理更具体的错误时，可以使用它！","进一步阅读#进一步阅读":"要了解有关在 Next.js 中处理错误的更多信息，请查看以下文档：\n错误处理\nerror.js API 参考\nnotFound() API 参考\nnot-found.js API 参考"}},"/chapter14":{"title":"提高可访问性","data":{"":"在上一章中，我们讨论了如何捕获错误（包括 404 错误）并向用户显示备用界面。然而，我们仍然需要讨论谜题的另一部分：form 验证。让我们看看如何使用 Server Actions 实现服务器端验证，以及如何使用 useFormState hook 在保持可访问性的同时展示 form 错误。以下是本章中将涵盖的主题：\n如何使用 eslint-plugin-jsx-a11y 与 Next.js 一起实现可访问性的最佳实践。\n如何实现服务器端 form 验证。\n如何使用 React 的 useFormState hook 处理 form 错误，并将其展示给用户。","什么是可访问性#什么是可访问性？":"可访问性是指设计和实现每个人都可以使用的 Web 应用程序，包括那些具有残障的人。这是一个广泛的主题，涵盖了许多领域，如键盘导航，语义 HTML，图像，颜色，视频等。虽然在这个课程中我们不会深入讨论可访问性，但我们将讨论 Next.js 中可用的可访问性功能以及一些常见的实践，以使您的应用程序更具可访问性。\n如果您想了解更多关于可访问性的信息，我们建议参阅 web.dev 的 “学习可访问性” 课程。","在-nextjs-中使用-eslint-可访问性插件#在 Next.js 中使用 ESLint 可访问性插件":"默认情况下，Next.js 包含 eslint-plugin-jsx-a11y 插件，以帮助早发现可访问性问题。例如，该插件会在没有 alt 文本的图像、错误使用 aria-* 和 role 属性等情况下发出警告。让我们看看这是如何工作的！在您的 package.json 文件中将 next lint 添加为一个脚本：\n\"scripts\": {\r\n    \"build\": \"next build\",\r\n    \"dev\": \"next dev\",\r\n    \"seed\": \"node -r dotenv/config ./scripts/seed.js\",\r\n    \"start\": \"next start\",\r\n    \"lint\": \"next lint\"\r\n},\n然后在终端中运行 npm run lint：\nnpm run lint\n您应该会看到以下警告：\n✔ No ESLint warnings or errors\n然而，如果您有一个没有 alt 文本的图像会发生什么呢？让我们试试！转到 /app/ui/invoices/table.tsx 并从图像中删除 alt 属性。您可以使用编辑器的搜索功能快速找到 <Image>：\n<Image\r\n  src={invoice.image_url}\r\n  className=\"rounded-full\"\r\n  width={28}\r\n  height={28}\r\n  alt={`${invoice.name}'s profile picture`} // 删除这一行\r\n/>\n现在再次运行 npm run lint，您应该会看到以下警告：\n./app/ui/invoices/table.tsx\r\n45:25  Warning: Image elements must have an alt prop,\r\neither with meaningful text, or an empty string for decorative images. jsx-a11y/alt-text\n如果您尝试将应用程序部署到 Vercel，此警告还将显示在构建日志中。这是因为 next lint 作为构建过程的一部分运行。因此，您可以在部署应用程序之前在本地运行 lint 以捕获可访问性问题。","提升-form-可访问性#提升 form 可访问性":"在我们的 form 中，已经有三件事情可以改进可访问性：\n语义化 HTML：使用语义元素（如<input>、<option> 等）而不是 <div>。这使辅助技术（AT）能够专注于输入元素，并向用户提供适当的上下文信息，使 form 更易于导航和理解。\n标签：包括 <label> 和 htmlFor 属性确保每个 form 字段都有一个描述性的文本标签。这通过提供上下文来改善AT支持，并通过允许用户单击标签以聚焦到相应的输入字段来增强可用性。\r\n** 聚焦轮廓（Focus Outline）：字段在聚焦时被正确地样式化，以显示轮廓。这对于可访问性至关重要，因为它在视觉上指示页面上的活动元素，帮助键盘和屏幕阅读器用户理解他们在 form 上的位置。您可以通过按 Tab 键进行验证。\n这些实践为使您的 forms 更适用于许多用户打下了良好的基础。然而，它们并没有解决 form 验证和错误的问题。","form-验证#Form 验证":"访问 http://localhost:3000/dashboard/invoices/create 并提交一个空 form。会发生什么？您会收到一个错误！这是因为您正在将空 form 值发送到您的 Server Action。您可以通过在客户端或服务器上验证 form 来防止这种情况。","客户端验证#客户端验证":"有几种方法可以在客户端验证 forms。最简单的方法是依赖浏览器提供的 form 验证，通过在 form 的 <input> 和<select> 元素中添加 required 属性。例如：\n<input\r\n  id=\"amount\"\r\n  name=\"amount\"\r\n  type=\"number\"\r\n  placeholder=\"Enter USD amount\"\r\n  className=\"peer block w-full rounded-md border border-gray-200 py-2 pl-10 text-sm outline-2 placeholder:text-gray-500\"\r\n  required\r\n/>\n再次提交 form，如果尝试提交带有空值的 form，您现在应该会看到浏览器发出的警告。这种方法通常是可以的，因为一些 ATs 支持浏览器验证。客户端验证的另一种选择是服务器端验证。让我们在下一节中看看如何实现它。目前，如果已添加 required 属性，请删除它们。","服务端验证#服务端验证":"通过在服务器上验证 form，您可以：\n确保数据发送到数据库之前是预期的格式。\n减少恶意用户绕过客户端验证的风险。\n拥有一个被认为是有效数据的真实来源。\n在 create-form.tsx 组件中，从 react-dom 中导入 useFormState hook。由于 useFormState 是一个hook，您将需要使用 \"use client\" 指令将您的 form 转换为客户端组件：\n'use client';\r\n \r\n// ...\r\nimport { useFormState } from 'react-dom';\n在 Form 组件内，使用 useFormState hook：\n接收两个参数：(action，initialState)。\n返回两个值：[state，dispatch] - form 状态和一个 dispatch 函数（类似于 useReducer）。\n将 createInvoice action 作为 useFormState 的参数传递，并在 <form action={}> 属性内调用 dispatch。\n// ...\r\nimport { useFormState } from 'react-dom';\r\n \r\nexport default function Form({ customers }: { customers: CustomerField[] }) {\r\n  const [state, dispatch] = useFormState(createInvoice, initialState);\r\n \r\n  return <form action={dispatch}>...</form>;\r\n}\ninitialState 可以是您定义的任何内容，在这个案例中，创建一个带有两个空 key（message 和 errors）的对象。\n// ...\r\nimport { useFormState } from 'react-dom';\r\n \r\nexport default function Form({ customers }: { customers: CustomerField[] }) {\r\n  const initialState = { message: null, errors: {} };\r\n  const [state, dispatch] = useFormState(createInvoice, initialState);\r\n \r\n  return <form action={dispatch}>...</form>;\r\n}\n这一开始看起来也许有点混乱，但一旦您更新 Server Action，它就会更加清晰。现在让我们做这个。在 action.ts 文件中，您可以使用 Zod 来验证 form 数据。更新您的 FormSchema 如下：\nconst FormSchema = z.object({\r\n  id: z.string(),\r\n  customerId: z.string({\r\n    invalid_type_error: 'Please select a customer.',\r\n  }),\r\n  amount: z.coerce\r\n    .number()\r\n    .gt(0, { message: 'Please enter an amount greater than $0.' }),\r\n  status: z.enum(['pending', 'paid'], {\r\n    invalid_type_error: 'Please select an invoice status.',\r\n  }),\r\n  date: z.string(),\r\n});\ncustomerId - 如果 customer 字段为空，Zod 会抛出一个错误，因为它期望是一个 string 类型。但是，让我们添加一条友好的提示消息，以防用户没有选择 customer。\namount - 由于您正在将 amount 类型从 string 强制转换为 number，如果字符串为空，则默认为零。使用 .gt() 函数告诉 Zod 我们始终希望 amount 大于 0。\nstatus - 如果 status 字段为空，Zod 会抛出一个错误，因为它期望是 \"pending\" 或 \"paid\"。让我们添加一条友好的提示消息，以防用户没有选择 status。\n接下来，更新您的 createInvoice 动作以接受两个参数：\n// This is temporary until @types/react-dom is updated\r\nexport type State = {\r\n  errors?: {\r\n    customerId?: string[];\r\n    amount?: string[];\r\n    status?: string[];\r\n  };\r\n  message?: string | null;\r\n};\r\n \r\nexport async function createInvoice(prevState: State, formData: FormData) {\r\n  // ...\r\n}\nformData - 与之前相同。\nprevState - 包含从 useFormState hook 传递的状态。在此示例中，您将不会在 action 中使用它，但它是一个必需的属性。\n然后，将 Zod 的 parse() 函数更改为 safeParse()：\nexport async function createInvoice(prevState: State, formData: FormData) {\r\n  // Validate form fields using Zod\r\n  const validatedFields = CreateInvoice.safeParse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n \r\n  // ...\r\n}\nsafeParse() 将返回一个包含 success 或 error 字段的对象。这将有助于更优雅地处理验证，而无需将此逻辑放在 try/catch 块中。在将信息发送到数据库之前，请使用条件语句检查 form 字段是否已正确验证：\nexport async function createInvoice(prevState: State, formData: FormData) {\r\n  // Validate form fields using Zod\r\n  const validatedFields = CreateInvoice.safeParse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n \r\n  // If form validation fails, return errors early. Otherwise, continue.\r\n  if (!validatedFields.success) {\r\n    return {\r\n      errors: validatedFields.error.flatten().fieldErrors,\r\n      message: 'Missing Fields. Failed to Create Invoice.',\r\n    };\r\n  }\r\n \r\n  // ...\r\n}\n如果 validatedFields 不成功，我们将提前返回带有 Zod 错误消息的函数。\nTip：使用 console.log validatedFields，并提交一个空 form 以查看其结构。\n最后，由于您正在单独处理 form 验证，不在 try/catch 块中，您可以为任何数据库错误返回一个特定的消息，您的最终代码应如下所示：\nexport async function createInvoice(prevState: State, formData: FormData) {\r\n  // Validate form using Zod\r\n  const validatedFields = CreateInvoice.safeParse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n \r\n  // If form validation fails, return errors early. Otherwise, continue.\r\n  if (!validatedFields.success) {\r\n    return {\r\n      errors: validatedFields.error.flatten().fieldErrors,\r\n      message: 'Missing Fields. Failed to Create Invoice.',\r\n    };\r\n  }\r\n \r\n  // Prepare data for insertion into the database\r\n  const { customerId, amount, status } = validatedFields.data;\r\n  const amountInCents = amount * 100;\r\n  const date = new Date().toISOString().split('T')[0];\r\n \r\n  // Insert data into the database\r\n  try {\r\n    await sql`\r\n      INSERT INTO invoices (customer_id, amount, status, date)\r\n      VALUES (${customerId}, ${amountInCents}, ${status}, ${date})\r\n    `;\r\n  } catch (error) {\r\n    // If a database error occurs, return a more specific error.\r\n    return {\r\n      message: 'Database Error: Failed to Create Invoice.',\r\n    };\r\n  }\r\n \r\n  // Revalidate the cache for the invoices page and redirect the user.\r\n  revalidatePath('/dashboard/invoices');\r\n  redirect('/dashboard/invoices');\r\n}\n太好了，现在让我们在您的 form 组件中展示错误。回到 create-form.tsx 组件，在该组件中，您可以使用 form 状态访问错误。添加一个三元运算符，检查每个特定的错误。例如，在 customer 字段之后，您可以添加：\n<form action={dispatch}>\r\n  <div className=\"rounded-md bg-gray-50 p-4 md:p-6\">\r\n    {/* Customer Name */}\r\n    <div className=\"mb-4\">\r\n      <label htmlFor=\"customer\" className=\"mb-2 block text-sm font-medium\">\r\n        Choose customer\r\n      </label>\r\n      <div className=\"relative\">\r\n        <select\r\n          id=\"customer\"\r\n          name=\"customerId\"\r\n          className=\"peer block w-full rounded-md border border-gray-200 py-2 pl-10 text-sm outline-2 placeholder:text-gray-500\"\r\n          defaultValue=\"\"\r\n          aria-describedby=\"customer-error\"\r\n        >\r\n          <option value=\"\" disabled>\r\n            Select a customer\r\n          </option>\r\n          {customers.map((name) => (\r\n            <option key={name.id} value={name.id}>\r\n              {name.name}\r\n            </option>\r\n          ))}\r\n        </select>\r\n        <UserCircleIcon className=\"pointer-events-none absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500\" />\r\n      </div>\r\n      <div id=\"customer-error\" aria-live=\"polite\" aria-atomic=\"true\">\r\n        {state.errors?.customerId &&\r\n          state.errors.customerId.map((error: string) => (\r\n            <p className=\"mt-2 text-sm text-red-500\" key={error}>\r\n              {error}\r\n            </p>\r\n          ))}\r\n      </div>\r\n    </div>\r\n    // ...\r\n  </div>\r\n</form>\nTip：您可以在组件内使用 console.log(state) 来检查是否一切都连接正确。在 Dev Tools 中检查控制台，因为您的 form 现在是一个客户端组件。\n在上面的代码中，您还添加了以下 aria 标签：\naria-describedby=\"customer-error\"：这在 select 元素和错误消息容器之间建立了关系。它表示具有 id=\"customer-error\" 的容器描述了 select 元素。屏幕阅读器在用户与选择框交互时将阅读此描述，以通知他们存在错误。\nid=\"customer-error\"：此 id 属性唯一标识包含 select 输入错误消息的 HTML 元素。这对于 aria-describedby 建立关系是必要的。\naria-live=\"polite\"：屏幕阅读器应在 div 内的错误更新时礼貌地通知用户。当内容发生更改时（例如，用户更正错误），屏幕阅读器将在用户处于空闲状态时宣布这些更改，以免打断他们。","练习添加-aria-标签#练习：添加 aria 标签":"使用上面的示例，添加错误到你的其余 form 字段。如果任何字段是错误的，您还应该在 form 底部展示一个消息。您的 UI 看起来应该如下所示：一切准备就绪后，运行 npm run lint 检查您是否正确使用了 aria 标签。如果您想挑战自己，请将本章学到的知识添加到 edit-form.tsx 组件中并进行 form 验证。您需要：\n在 edit-form.tsx 组件中添加 useFormState。\n编辑 updateInvoice 操作以处理来自 Zod 的验证错误。\n在组件中展示错误，并添加 aria 标签以提高可访问性。\n准备好后，请展开下面的代码片段查看解决方案：\n点击展开/折叠\n编辑发票 Form:\nexport default function EditInvoiceForm({\r\n  invoice,\r\n  customers,\r\n}: {\r\n  invoice: InvoiceForm;\r\n  customers: CustomerField[];\r\n}) {\r\n  const initialState = { message: null, errors: {} };\r\n  const updateInvoiceWithId = updateInvoice.bind(null, invoice.id);\r\n  const [state, dispatch] = useFormState(updateInvoiceWithId, initialState);\r\n\r\n  return <form action={dispatch}></form>;\r\n}\nServer Action:\nexport async function updateInvoice(\r\n  id: string,\r\n  prevState: State,\r\n  formData: FormData,\r\n) {\r\n  const validatedFields = UpdateInvoice.safeParse({\r\n    customerId: formData.get('customerId'),\r\n    amount: formData.get('amount'),\r\n    status: formData.get('status'),\r\n  });\r\n\r\n  if (!validatedFields.success) {\r\n    return {\r\n      errors: validatedFields.error.flatten().fieldErrors,\r\n      message: 'Missing Fields. Failed to Update Invoice.',\r\n    };\r\n  }\r\n\r\n  const { customerId, amount, status } = validatedFields.data;\r\n  const amountInCents = amount * 100;\r\n\r\n  try {\r\n    await sql`\r\n      UPDATE invoices\r\n      SET customer_id = ${customerId}, amount = ${amountInCents}, status = ${status}\r\n      WHERE id = ${id}\r\n    `;\r\n  } catch (error) {\r\n    return { message: 'Database Error: Failed to Update Invoice.' };\r\n  }\r\n\r\n  revalidatePath('/dashboard/invoices');\r\n  redirect('/dashboard/invoices');\r\n}"}},"/chapter11":{"title":"添加搜索和分页","data":{"":"在前一章中，通过流式传输提高了 Dashboard 的初始加载性能。现在让我们转到 /invoices 页面，学习如何添加搜索和分页！以下是本章中将涵盖的主题：\n学习如何使用 Next.js 的 API：searchParams、usePathname 和 useRouter。\n使用 URL 搜索参数实现搜索和分页。","初始代码#初始代码":"在您的 /dashboard/invoices/page.tsx 文件中，粘贴以下代码：\nimport Pagination from '@/app/ui/invoices/pagination';\r\nimport Search from '@/app/ui/search';\r\nimport Table from '@/app/ui/invoices/table';\r\nimport { CreateInvoice } from '@/app/ui/invoices/buttons';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport { InvoicesTableSkeleton } from '@/app/ui/skeletons';\r\nimport { Suspense } from 'react';\r\n\r\nexport default async function Page() {\r\n  return (\r\n    <div className=\"w-full\">\r\n      <div className=\"flex w-full items-center justify-between\">\r\n        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>\r\n      </div>\r\n      <div className=\"mt-4 flex items-center justify-between gap-2 md:mt-8\">\r\n        <Search placeholder=\"Search invoices...\" />\r\n        <CreateInvoice />\r\n      </div>\r\n      {/*  <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>\r\n        <Table query={query} currentPage={currentPage} />\r\n      </Suspense> */}\r\n      <div className=\"mt-5 flex w-full justify-center\">\r\n        {/* <Pagination totalPages={totalPages} /> */}\r\n      </div>\r\n    </div>\r\n  );\r\n}\n花一些时间熟悉页面和您将要使用的组件：\n<Search/> 允许用户搜索特定的发票。\n<Pagination/> 允许用户在发票的页面之间导航。\n<Table/> 显示发票。\n您的搜索功能将跨足客户端和服务器。当用户在客户端搜索发票时，URL 参数将被更新，在服务器上获取数据，并使用新数据重新呈现表格。","为什么使用-url-搜索参数#为什么使用 URL 搜索参数？":"如上所述，您将使用 URL 搜索参数来管理搜索状态。如果您习惯于使用客户端状态进行搜索，这种模式可能是新的。使用 URL 参数实现搜索有一些好处：\n书签和共享的 URL：由于搜索参数在 URL 中，用户可以将应用程序的当前状态，包括其搜索查询和过滤器，收藏夹起来以供将来参考或分享。\n服务器端渲染和初始加载：可以直接在服务器上使用 URL 参数以呈现初始状态，使处理服务器端渲染变得更容易。\n分析和跟踪：直接在 URL 中包含搜索查询和过滤器使得更容易跟踪用户行为，而无需额外的客户端逻辑。","添加搜索功能#添加搜索功能":"以下是您将用于实现搜索功能的 Next.js 客户端 hooks：\nuseSearchParams - 允许您访问当前 URL 的参数。例如，此 URL /dashboard/invoices?page=1&query=pending 的搜索参数将是：{page: '1', query: 'pending'}。\nusePathname - 允许您读取当前 URL 的路径名。例如，对于路由 /dashboard/invoices，usePathname 将返回 '/dashboard/invoices'。\nuseRouter - 使您能够在客户端组件内以编程方式在路由之间导航。有多种方法可供您使用。\n以下是实现步骤的快速概述：\n捕获用户的输入。\n使用搜索参数更新 URL。\n保持 URL 与输入字段同步。\n更新表以反映搜索查询。","1-捕获用户的输入#1. 捕获用户的输入":"进入 <Search> 组件（/app/ui/search.tsx），您会注意到：\n\"use client\" - 这是一个客户端组件，这意味着您可以使用事件监听器和 hook。\n<input> - 这是搜索输入。\n创建一个新的 handleSearch 函数，并为 <input> 元素添加一个 onChange 监听器。每当输入值发生变化时，onChange 将调用 handleSearch。\n'use client';\r\n \r\nimport { MagnifyingGlassIcon } from '@heroicons/react/24/outline';\r\n \r\nexport default function Search({ placeholder }: { placeholder: string }) {\r\n  function handleSearch(term: string) {\r\n    console.log(term);\r\n  }\r\n \r\n  return (\r\n    <div className=\"relative flex flex-1 flex-shrink-0\">\r\n      <label htmlFor=\"search\" className=\"sr-only\">\r\n        Search\r\n      </label>\r\n      <input\r\n        className=\"peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500\"\r\n        placeholder={placeholder}\r\n        onChange={(e) => {\r\n          handleSearch(e.target.value);\r\n        }}\r\n      />\r\n      <MagnifyingGlassIcon className=\"absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500 peer-focus:text-gray-900\" />\r\n    </div>\r\n  );\r\n}\n打开开发者工具中的控制台（console）测试上述代码是否正常工作，然后在搜索框架内输入内容。您应该在控制台中看到搜索词被记录。太棒了！您已经捕获了用户的搜索输入。现在，您需要使用搜索词更新 URL。","2-随着搜索参数更新-url#2. 随着搜索参数更新 URL":"从 'next/navigation' 导入 useSearchParams hook， 并将其赋值给一个变量：\n'use client';\r\n \r\nimport { MagnifyingGlassIcon } from '@heroicons/react/24/outline';\r\nimport { useSearchParams } from 'next/navigation';\r\n \r\nexport default function Search() {\r\n  const searchParams = useSearchParams();\r\n \r\n  function handleSearch(term: string) {\r\n    console.log(term);\r\n  }\r\n  // ...\r\n}\n在 handleSearch 中，使用新的 searchParams 变量创建一个新的 URLSearchParams 实例。\n'use client';\r\n \r\nimport { MagnifyingGlassIcon } from '@heroicons/react/24/outline';\r\nimport { useSearchParams } from 'next/navigation';\r\n \r\nexport default function Search() {\r\n  const searchParams = useSearchParams();\r\n \r\n  function handleSearch(term: string) {\r\n    const params = new URLSearchParams(searchParams);\r\n  }\r\n  // ...\r\n}\nURLSearchParams 是一个 Web API，提供了操纵 URL 查询参数的实用方法。与创建复杂的字符串文字不同，您可以使用它获取参数字符串，例如 ?page=1&query=a。接下来，根据用户的输入设置 params 字符串。如果输入为空，您将要删除它：\n'use client';\r\n \r\nimport { MagnifyingGlassIcon } from '@heroicons/react/24/outline';\r\nimport { useSearchParams } from 'next/navigation';\r\n \r\nexport default function Search() {\r\n  const searchParams = useSearchParams();\r\n \r\n  function handleSearch(term: string) {\r\n    const params = new URLSearchParams(searchParams);\r\n    if (term) {\r\n      params.set('query', term);\r\n    } else {\r\n      params.delete('query');\r\n    }\r\n  }\r\n  // ...\r\n}\n现在您有了查询字符串。您可以使用 Next.js 的 useRouter 和 usePathname hook 来更新 URL。从 'next/navigation' 导入 useRouter 和 usePathname，并在 handleSearch 中使用 useRouter() 的 replace 方法：\n'use client';\r\n \r\nimport { MagnifyingGlassIcon } from '@heroicons/react/24/outline';\r\nimport { useSearchParams, usePathname, useRouter } from 'next/navigation';\r\n \r\nexport default function Search() {\r\n  const searchParams = useSearchParams();\r\n  const pathname = usePathname();\r\n  const { replace } = useRouter();\r\n \r\n  function handleSearch(term: string) {\r\n    const params = new URLSearchParams(searchParams);\r\n    if (term) {\r\n      params.set('query', term);\r\n    } else {\r\n      params.delete('query');\r\n    }\r\n    replace(`${pathname}?${params.toString()}`);\r\n  }\r\n}\n这里是正在发生的事情的详细说明：\n${pathname} 是当前路径，在您的案例中是 \"/dashboard/invoices\"。\n当用户在搜索栏中键入时，params.toString() 将此输入转换为友好的 URL 格式。\nreplace(${pathname}?${params.toString()}) 更新 URL，其中包含用户的搜索数据。例如，如果用户搜索 \"Lee\"，则为 /dashboard/invoices?query=lee。\n由于 Next.js 的客户端导航（您在导航页面的章节中了解到的）URL 无需重新加载页面即可更新。","3-保持-url-和输入同步#3. 保持 URL 和输入同步":"为确保输入字段与 URL 同步，并在共享时填充，您可以通过从 searchParams 中读取传递一个 defaultValue 给 input：\n<input\r\n  className=\"peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500\"\r\n  placeholder={placeholder}\r\n  onChange={(e) => {\r\n    handleSearch(e.target.value);\r\n  }}\r\n  defaultValue={searchParams.get('query')?.toString()}\r\n/>\ndefaultValue vs. value / 受控 vs. 不受控\n如果您使用状态来管理输入的值，您将使用 value 属性使其成为受控组件。这意味着 React 将管理输入的状态。\n然而，由于您没有使用状态，您可以使用 defaultValue。这意味着原生输入将管理自己的状态。这是可以的，因为您将搜索查询保存到 URL 而不是状态。","4-更新表格#4. 更新表格":"最后，您需要更新表格组件以反映搜索查询。导航回到发票页面。页面组件接受一个名为 searchParams 的 prop，因此您可以将当前的 URL 参数传递给 <Table> 组件。\nimport Pagination from '@/app/ui/invoices/pagination';\r\nimport Search from '@/app/ui/search';\r\nimport Table from '@/app/ui/invoices/table';\r\nimport { CreateInvoice } from '@/app/ui/invoices/buttons';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport { Suspense } from 'react';\r\nimport { InvoicesTableSkeleton } from '@/app/ui/skeletons';\r\n \r\nexport default async function Page({\r\n  searchParams,\r\n}: {\r\n  searchParams?: {\r\n    query?: string;\r\n    page?: string;\r\n  };\r\n}) {\r\n  const query = searchParams?.query || '';\r\n  const currentPage = Number(searchParams?.page) || 1;\r\n \r\n  return (\r\n    <div className=\"w-full\">\r\n      <div className=\"flex w-full items-center justify-between\">\r\n        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>\r\n      </div>\r\n      <div className=\"mt-4 flex items-center justify-between gap-2 md:mt-8\">\r\n        <Search placeholder=\"Search invoices...\" />\r\n        <CreateInvoice />\r\n      </div>\r\n      <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>\r\n        <Table query={query} currentPage={currentPage} />\r\n      </Suspense>\r\n      <div className=\"mt-5 flex w-full justify-center\">\r\n        {/* <Pagination totalPages={totalPages} /> */}\r\n      </div>\r\n    </div>\r\n  );\r\n}\n如果导航到 <Table> 组件，您将看到两个 prop，query 和 currentPage，传递给 fetchFilteredInvoices() 函数，该函数返回与查询匹配的发票。\n// ...\r\nexport default async function InvoicesTable({\r\n  query,\r\n  currentPage,\r\n}: {\r\n  query: string;\r\n  currentPage: number;\r\n}) {\r\n  const invoices = await fetchFilteredInvoices(query, currentPage);\r\n  // ...\r\n}\n有了这些变化，继续测试。如果搜索一个词，您将更新 URL，这将向服务器发送一个新的请求，在服务器上获取数据，只有与查询匹配的发票将被返回。\n何时使用 useSearchParams() hook vs. searchParams prop？\n您可能已经注意到您使用了两种不同的方法来提取搜索参数。您使用其中一种取决于您是在客户端还是服务器上工作。\n<Search> 是一个客户端组件，因此您使用 useSearchParams() hook 从客户端访问参数。\n<Table> 是一个服务器组件，它自己获取数据，因此您可以将 searchParams prop 从页面传递给组件。\n作为一般规则，如果要从客户端读取参数，请使用 useSearchParams() hook，因为这样可以避免返回到服务器。","最佳实践防抖#最佳实践：防抖":"恭喜！您已经在 Next.js 中实现了搜索！但是有一些优化操作可以进行。在您的 handleSearch 函数内部，添加以下 console.log：\nfunction handleSearch(term: string) {\r\n  console.log(`Searching... ${term}`);\r\n \r\n  const params = new URLSearchParams(searchParams);\r\n  if (term) {\r\n    params.set('query', term);\r\n  } else {\r\n    params.delete('query');\r\n  }\r\n  replace(`${pathname}?${params.toString()}`);\r\n}\n然后在搜索栏中键入 \"Emil\" 并检查开发工具中的控制台。发生了什么？\nSearching... E\r\nSearching... Em\r\nSearching... Emi\r\nSearching... Emil\n您在每次按键时都更新了 URL，因此在每次按键时都在查询数据库！虽然在我们的应用程序中这不是问题，但想象一下如果您的应用程序有数千用户，每个用户在每次按键时都向数据库发送新请求，那将会是一个问题。防抖是一种编程实践，用于限制函数触发的速率。在我们的情况下，只有在用户停止输入时才希望查询数据库。防抖的工作原理：\n触发事件：当发生应该被防抖的事件（比如搜索框中的按键）时，定时器启动。\n等待：如果在计时器到期之前发生新事件，则重置计时器。\n执行：如果计时器达到倒计时结束，将执行防抖函数。\n您可以以几种方式实现防抖，包括手动创建自己的防抖函数。为了保持简单，我们将使用一个名为 use-debounce 的库。安装 use-debounce：\nnpm i use-debounce\n在您的 <Search> 组件中，导入一个名为 useDebouncedCallback 的函数：\n// ...\r\nimport { useDebouncedCallback } from 'use-debounce';\r\n \r\n// Inside the Search Component...\r\nconst handleSearch = useDebouncedCallback((term) => {\r\n  console.log(`Searching... ${term}`);\r\n \r\n  const params = new URLSearchParams(searchParams);\r\n  if (term) {\r\n    params.set('query', term);\r\n  } else {\r\n    params.delete('query');\r\n  }\r\n  replace(`${pathname}?${params.toString()}`);\r\n}, 300);\n这个函数将包装 handleSearch 的内容，并且只有在用户停止输入一段时间后（300 毫秒）才运行代码。现在再次在搜索栏中键入，并在开发工具中打开控制台。您应该会看到以下内容：\nSearching... Emil\n通过防抖，您可以减少发送到数据库的请求数量，从而节省资源。","添加分页#添加分页":"在引入搜索功能之后，您会注意到表格一次只显示 6 张发票。这是因为 data.ts 中的 fetchFilteredInvoices() 函数每页返回最多 6 张发票。添加分页允许用户浏览不同页面以查看所有发票。让我们看看如何使用 URL 参数实现分页，就像您在搜索中所做的那样。导航到 <Pagination/> 组件，您会注意到它是一个客户端组件。您不希望在客户端上获取数据，因为这会暴露您的数据库凭据（请记住，您没有使用 API 层）。相反，您可以在服务器上获取数据，并将其作为 prop 传递给组件。在 /dashboard/invoices/page.tsx 中，导入一个名为 fetchInvoicesPages 的新函数，并将 searchParams 中的查询作为参数传递：\n// ...\r\nimport { fetchInvoicesPages } from '@/app/lib/data';\r\n \r\nexport default async function Page({\r\n  searchParams,\r\n}: {\r\n  searchParams?: {\r\n    query?: string,\r\n    page?: string,\r\n  },\r\n}) {\r\n  const query = searchParams?.query || '';\r\n  const currentPage = Number(searchParams?.page) || 1;\r\n \r\n  const totalPages = await fetchInvoicesPages(query);\r\n \r\n  return (\r\n    // ...\r\n  );\r\n}\nfetchInvoicesPages 根据搜索查询返回页面的总数。例如，如果有 12 张与搜索查询匹配的发票，并且每页显示 6 张发票，那么总页数将为 2。接下来，将 totalPages 属性传递给 <Pagination/> 组件：\n// ...\r\n \r\nexport default async function Page({\r\n  searchParams,\r\n}: {\r\n  searchParams?: {\r\n    query?: string;\r\n    page?: string;\r\n  };\r\n}) {\r\n  const query = searchParams?.query || '';\r\n  const currentPage = Number(searchParams?.page) || 1;\r\n \r\n  const totalPages = await fetchInvoicesPages(query);\r\n \r\n  return (\r\n    <div className=\"w-full\">\r\n      <div className=\"flex w-full items-center justify-between\">\r\n        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>\r\n      </div>\r\n      <div className=\"mt-4 flex items-center justify-between gap-2 md:mt-8\">\r\n        <Search placeholder=\"Search invoices...\" />\r\n        <CreateInvoice />\r\n      </div>\r\n      <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>\r\n        <Table query={query} currentPage={currentPage} />\r\n      </Suspense>\r\n      <div className=\"mt-5 flex w-full justify-center\">\r\n        <Pagination totalPages={totalPages} />\r\n      </div>\r\n    </div>\r\n  );\r\n}\n导航到 <Pagination/> 组件并导入 usePathname 和 useSearchParams hooks。我们将使用这两者来获取当前页并设置新的页数。确保在此组件中取消注释代码。由于您尚未实现 <Pagination/> 逻辑，您的应用程序将暂时中断。现在让我们来做这个！\n'use client';\r\n \r\nimport { ArrowLeftIcon, ArrowRightIcon } from '@heroicons/react/24/outline';\r\nimport clsx from 'clsx';\r\nimport Link from 'next/link';\r\nimport { generatePagination } from '@/app/lib/utils';\r\nimport { usePathname, useSearchParams } from 'next/navigation';\r\n \r\nexport default function Pagination({ totalPages }: { totalPages: number }) {\r\n  const pathname = usePathname();\r\n  const searchParams = useSearchParams();\r\n  const currentPage = Number(searchParams.get('page')) || 1;\r\n \r\n  // ...\r\n}\n接下来，在 <Pagination> 组件中创建一个名为 createPageURL 的新函数。类似于搜索，您将使用 URLSearchParams 来设置新的页码，并使用 pathName 创建 URL 字符串。\n'use client';\r\n \r\nimport { ArrowLeftIcon, ArrowRightIcon } from '@heroicons/react/24/outline';\r\nimport clsx from 'clsx';\r\nimport Link from 'next/link';\r\nimport { generatePagination } from '@/app/lib/utils';\r\nimport { usePathname, useSearchParams } from 'next/navigation';\r\n \r\nexport default function Pagination({ totalPages }: { totalPages: number }) {\r\n  const pathname = usePathname();\r\n  const searchParams = useSearchParams();\r\n  const currentPage = Number(searchParams.get('page')) || 1;\r\n \r\n  const createPageURL = (pageNumber: number | string) => {\r\n    const params = new URLSearchParams(searchParams);\r\n    params.set('page', pageNumber.toString());\r\n    return `${pathname}?${params.toString()}`;\r\n  };\r\n \r\n  // ...\r\n}\n这里是正在发生的事情的详细说明：\ncreatePageURL 创建当前搜索参数的实例。\n然后，它更新 \"page\" 参数为提供的 pageNumber。\n最后，使用 pathname 和更新后的搜索参数构造完整的 URL。\n<Pagination> 组件的其余部分涉及样式和不同状态（第一页、最后一页、活动、禁用等）。我们不会详细介绍这门课程，但请随时查看代码以查看 createPageURL 在哪里被调用。最后，当用户键入新的搜索查询时，您希望将页码重置为 1。您可以通过更新 <Search> 组件中的 handleSearch 函数来实现这一点：\n'use client';\r\n \r\nimport { MagnifyingGlassIcon } from '@heroicons/react/24/outline';\r\nimport { usePathname, useRouter, useSearchParams } from 'next/navigation';\r\nimport { useDebouncedCallback } from 'use-debounce';\r\n \r\nexport default function Search({ placeholder }: { placeholder: string }) {\r\n  const searchParams = useSearchParams();\r\n  const { replace } = useRouter();\r\n  const pathname = usePathname();\r\n \r\n  const handleSearch = useDebouncedCallback((term) => {\r\n    const params = new URLSearchParams(searchParams);\r\n    params.set('page', '1');\r\n    if (term) {\r\n      params.set('query', term);\r\n    } else {\r\n      params.delete('query');\r\n    }\r\n    replace(`${pathname}?${params.toString()}`);\r\n  }, 300);\r\n}","总结#总结":"恭喜你！你刚刚使用 URL 参数和 Next.js API 实现了搜索和分页。总结一下，在本章中：\n你使用 URL 搜索参数而不是客户端状态处理了搜索和分页。\n你在服务器上获取了数据。\n你使用了 useRouter 路由 Hook 以实现更平滑的客户端过渡。\n这些模式与你在使用客户端 React 时可能习惯的方式有所不同，但希望现在你更好地理解了使用 URL 搜索参数并将该状态提升到服务器的好处。"}},"/chapter18":{"title":"Next.js 学习资源","data":{"":"这里将汇总一些 Next.js 的学习资源，欢迎您分享!。","文档#文档":"Next.js 官方文档：Next.js 的文档写的还是挺好的，刚开始接触 Next.js，笔者主要看的也是该文档。\nLearn Next.js 官方英文教程\nLearn Next.js 中文翻译教程","项目#项目":"Next.js 模板：这是 Next.js 官方维护的 Next.js 模版仓库，包含很多应用类型，可以去看看哦！\n10 个 React Server Component + Next.js 开源项目分享","视频#视频":"Vercel 的油管账号：上面有很多 Next.js 相关视频教程\n...更多内容，等您来贡献，欢迎提 PR！"}},"/chapter2":{"title":"CSS 样式","data":{"":"当前，您的首页没有任何样式。让我们看看为 Next.js 应用程序添加样式的不同方法。以下是本章中将涵盖的主题：\n如何向应用程序添加全局 CSS 文件。\n两种不同的样式方式：Tailwind 和 CSS Modules。\n如何使用 clsx 实用程序包有条件地添加类名。","全局样式#全局样式":"如果您查看 /app/ui 文件夹内，您会看到一个名为 global.css 的文件。您可以使用此文件向应用程序的所有路由添加 CSS 规则，例如 CSS 重置规则、用于链接等 HTML 元素的全局样式等。您可以在应用程序中的任何组件中导入 global.css，但通常最好的做法是将其添加到顶级组件中。在 Next.js 中，这就是根布局（稍后会详细介绍）。在 /app/layout.tsx 文件内导入 global.css 样式文件，将全局样式添加到您的应用程序：\nimport '@/app/ui/global.css';\r\n \r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode;\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body>{children}</body>\r\n    </html>\r\n  );\r\n}\n保存更改并在浏览器中预览。您的首页现在应该如下所示：但等一下，您并没有添加任何 CSS 规则，样式是从哪里来的？如果您查看 global.css 内部，您会注意到一些 @tailwind 指令：\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;","tailwind#Tailwind":"Tailwind 是一个 CSS 框架，通过允许您在 TSX 标记中直接快速编写实用类，加速开发过程。在 Tailwind 中，您通过添加类名来为元素添加样式。例如，添加类 \"text-blue-500\" 将使 <h1> 文本变成蓝色：\n<h1 className=\"text-blue-500\">I'm blue!</h1>\n尽管 CSS 样式在全局共享，但每个类都是单独应用于每个元素。这意味着如果您添加或删除一个元素，您不必担心维护单独的样式表、样式冲突或者随着应用程序规模扩大而增加 CSS 捆绑的大小。当您使用 create-next-app 启动新项目时，Next.js 会询问您是否要使用 Tailwind。如果选择 Yes，Next.js 将自动安装必要的包并在您的应用程序中配置 Tailwind。如果您查看 /app/page.tsx，您将看到我们在示例中使用 Tailwind 类。\nimport AcmeLogo from '@/app/ui/acme-logo';\r\nimport Link from 'next/link';\r\n \r\nexport default function Page() {\r\n  return (\r\n    // These are Tailwind classes:\r\n    <main className=\"flex min-h-screen flex-col p-6\">\r\n      <div className=\"flex h-20 shrink-0 items-end rounded-lg bg-blue-500 p-4 md:h-52\">\r\n    // ...\r\n  )\r\n}\n如果这是您第一次使用 Tailwind，请不要担心。为了节省时间，我们已经为您样式化了所有要使用的组件。让我们玩一下 Tailwind！复制下面的代码并将其粘贴到 /app/page.tsx 中 <p> 元素上方：\n<div\r\n  className=\"h-0 w-0 border-b-[30px] border-l-[20px] border-r-[20px] border-b-black border-l-transparent border-r-transparent\"\r\n/>\n如果你更喜欢编写传统的 CSS 规则或者希望将样式与 JSX 代码分开 - CSS Modules 是一个很好的选择。","css-modules#CSS Modules":"CSS Modules 允许你通过自动生成独特的类名将 CSS 限定在一个组件中，这样你就不必担心样式冲突。在这个课程中，我们将继续使用 Tailwind，但让我们花一点时间看看如何使用 CSS 模块来实现上面小测验的相同效果。在 /app/ui 目录下，创建一个名为 home.module.css 的新文件，然后添加以下 CSS 规则：\n.shape {\r\n  height: 0;\r\n  width: 0;\r\n  border-bottom: 30px solid black;\r\n  border-left: 20px solid transparent;\r\n  border-right: 20px solid transparent;\r\n}\n然后，在你的 /app/page.tsx 文件中导入这些样式，并用 styles.shape 替换你添加的 <div> 中的 Tailwind 类名：\nimport styles from '@/app/ui/home.module.css';\r\n\r\n//...\r\n<div className=\"flex flex-col justify-center gap-6 rounded-lg bg-gray-50 px-6 py-10 md:w-2/5 md:px-20\">\r\n    <div className={styles.shape}></div>;\r\n// ...\n保存更改并在浏览器中预览。你应该看到与之前相同的形状。Tailwind 和 CSS 模块是样式化 Next.js 应用程序的两种最常见的方法。使用其中之一取决于个人喜好 - 你甚至可以在同一个应用程序中同时使用它们两者！","使用-clsx-库切换类名#使用 clsx 库切换类名":"在某些情况下，您可能需要根据状态或其他条件有条件地为元素设置样式。clsx 是一个库，让您可以轻松地切换类名。我们建议查看文档以获取更多详细信息，但以下是基本用法：\n假设您想要创建一个名为 InvoiceStatus 的组件，该组件接受状态。状态可以是 'pending' 或 'paid'。\n如果是 'paid'，您希望颜色是绿色。如果是 'pending'，您希望颜色是灰色。\n您可以使用 clsx 来有条件地应用类，例如：\nimport clsx from 'clsx';\r\n \r\nexport default function InvoiceStatus({ status }: { status: string }) {\r\n  return (\r\n    <span\r\n      className={clsx(\r\n        'inline-flex items-center rounded-full px-2 py-1 text-sm',\r\n        {\r\n          'bg-gray-100 text-gray-500': status === 'pending',\r\n          'bg-green-500 text-white': status === 'paid',\r\n        },\r\n      )}\r\n    >\r\n    // ...\r\n)}","其他样式解决方案#其他样式解决方案":"除了我们讨论过的方法之外，您还可以使用以下方式为 Next.js 应用程序添加样式：\nSass： 允许您导入 .css 和 .scss 文件。\nCSS-in-JS 库： 例如 styled-jsx、styled-components 和 emotion。\n查看 CSS 文档以获取更多信息。"}},"/chapter5":{"title":"页面之间导航","data":{"":"在上一章中，您创建了 dashboard 的布局和页面。现在，让我们添加一些链接，以便用户可以在仪表板路由之间进行导航。以下是本章中将涵盖的主题：\n如何使用 next/link 组件。\n如何使用 usePathname() 钩子显示活动链接。\nNext.js 中导航的工作原理。","为什么要优化导航#为什么要优化导航？":"为了在页面之间创建链接，传统上会使用 <a> HTML 元素。目前，侧边栏链接使用 <a> 元素，但请注意在浏览器中在主页、发票和客户页面之间导航时发生了什么。您看到了吗？每次页面导航时都会出现完整的页面刷新！","link-组件#<Link> 组件":"在 Next.js 中，您可以使用 <Link /> 组件在应用程序的页面之间进行链接。<Link> 允许您使用 JavaScript 进行客户端导航。要使用 <Link /> 组件，请打开 /app/ui/dashboard/nav-links.tsx，并从 next/link 导入 Link 组件。然后，将 <a> 标签替换为 <Link>：\nimport {\r\n  UserGroupIcon,\r\n  HomeIcon,\r\n  DocumentDuplicateIcon,\r\n} from '@heroicons/react/24/outline';\r\nimport Link from 'next/link';\r\n \r\n// ...\r\n \r\nexport default function NavLinks() {\r\n  return (\r\n    <>\r\n      {links.map((link) => {\r\n        const LinkIcon = link.icon;\r\n        return (\r\n          <Link\r\n            key={link.name}\r\n            href={link.href}\r\n            className=\"flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3\"\r\n          >\r\n            <LinkIcon className=\"w-6\" />\r\n            <p className=\"hidden md:block\">{link.name}</p>\r\n          </Link>\r\n        );\r\n      })}\r\n    </>\r\n  );\r\n}\n正如您所见，Link 组件类似于使用 <a> 标签，但是您使用的不是 <a href=\"…\">，而是 <Link href=\"…\">。保存更改并检查它是否在您的 localhost 上运行。现在，您应该能够在页面之间导航，而无需看到完整的刷新。尽管应用程序的某些部分是在服务器上渲染的，但没有完整的页面刷新，使其感觉像一个 web 应用程序。这是为什么呢？","自动代码拆分和预取#自动代码拆分和预取":"为了提高导航体验，Next.js 会自动按路由段拆分您的应用程序。这与传统的 React SPA 不同，传统 SPA 在初始加载时会加载应用程序的所有代码。按路由拆分代码意味着页面变得隔离。如果某个页面抛出错误，应用程序的其余部分仍将正常工作。此外，在生产环境中，每当 <Link> 组件出现在浏览器的视口中时，Next.js 会自动在后台预取链接路由的代码。当用户点击链接时，目标页面的代码将在后台已经加载，这就是使页面过渡几乎瞬间完成的原因！了解更多关于导航如何工作的信息。","模式显示活动链接#模式：显示活动链接":"一种常见的用户界面模式是显示活动链接，以向用户指示他们当前所在的页面。为了做到这一点，您需要从 URL 中获取用户当前的路径。Next.js 提供了一个名为 usePathname() 的钩子，您可以使用它来检查路径并实现此模式。由于 usePathname() 是一个钩子，您需要将 nav-links.tsx 转换为客户端组件。在文件顶部添加 React 的 \"use client\" 指令，然后从 next/navigation 导入 usePathname()：\n'use client';\r\n \r\nimport {\r\n  UserGroupIcon,\r\n  HomeIcon,\r\n  InboxIcon,\r\n} from '@heroicons/react/24/outline';\r\nimport Link from 'next/link';\r\nimport { usePathname } from 'next/navigation';\r\n \r\n// ...\n接下来，在你的 <NavLinks /> 组件内部，将路径赋值给一个名为 pathname 的变量：\nexport default function NavLinks() {\r\n  const pathname = usePathname();\r\n  // ...\r\n}\n你可以使用在 CSS 样式章节介绍的 clsx 库，在链接处于活动状态时有条件地应用类名。当 link.href 与 pathname 匹配时，链接应该显示为蓝色文本和浅蓝色背景。以下是 nav-links.tsx 的最终代码：\n'use client';\r\n \r\nimport {\r\n  UserGroupIcon,\r\n  HomeIcon,\r\n  DocumentDuplicateIcon,\r\n} from '@heroicons/react/24/outline';\r\nimport Link from 'next/link';\r\nimport { usePathname } from 'next/navigation';\r\nimport clsx from 'clsx';\r\n \r\n// ...\r\n \r\nexport default function NavLinks() {\r\n  const pathname = usePathname();\r\n \r\n  return (\r\n    <>\r\n      {links.map((link) => {\r\n        const LinkIcon = link.icon;\r\n        return (\r\n          <Link\r\n            key={link.name}\r\n            href={link.href}\r\n            className={clsx(\r\n              'flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3',\r\n              {\r\n                'bg-sky-100 text-blue-600': pathname === link.href,\r\n              },\r\n            )}\r\n          >\r\n            <LinkIcon className=\"w-6\" />\r\n            <p className=\"hidden md:block\">{link.name}</p>\r\n          </Link>\r\n        );\r\n      })}\r\n    </>\r\n  );\r\n}\n保存并检查你的本地主机。现在，你应该看到活动链接以蓝色突出显示。"}},"/chapter6":{"title":"建立你的数据库","data":{"":"在继续工作于你的 dashboard 之前，你需要一些数据。在这一章中，你将使用 @vercel/postgres 来设置一个 PostgreSQL 数据库。如果你已经熟悉 PostgreSQL 并且更愿意使用自己的提供者，你可以跳过这一章并自行设置。否则，让我们继续吧！以下是本章中将涵盖的主题：\n将你的项目推送到 GitHub。\n设置 Vercel 账户并链接你的 GitHub 存储库以进行即时预览和部署。\n创建并将你的项目链接到一个 PostgreSQL 数据库。\n使用初始数据填充数据库。","创建-github-存储库#创建 GitHub 存储库":"首先，如果你还没有这样做，让我们将你的存储库推送到 GitHub。这将使设置数据库和部署变得更容易。如果你需要帮助设置你的存储库，请查看 GitHub 上的这篇指南。\n需要注意的是：\n你也可以使用其他 Git 提供者，如 GitLab 或 Bitbucket。\n如果你对 GitHub 不熟悉，我们推荐使用 GitHub Desktop App 以简化开发工作流程。","创建-vercel-账户#创建 Vercel 账户":"访问 vercel.com/signup 创建一个账户。选择免费的 \"hobby\" 计划。选择 \"Continue with GitHub\" 来连接你的 GitHub 和 Vercel 账户。","连接并部署你的项目#连接并部署你的项目":"接下来，你将被带到这个屏幕，在这里你可以选择导入你刚刚创建的 GitHub 存储库：给你的项目取一个名字，然后点击 Deploy（部署）。太棒了！🎉 你的项目现在已经部署完成。通过连接你的 GitHub 存储库，每当你推送更改到主分支时，Vercel 将自动重新部署你的应用程序，无需额外配置。在发起拉取请求时，你还将获得即时预览，这样你就可以及早发现部署错误，并与团队成员分享项目的预览以获得反馈。","创建一个-postgres-数据库#创建一个 Postgres 数据库":"接下来，为了设置数据库，点击 Continue to Dashboard 并从项目仪表板中选择 Storage 选项卡。选择 Connect Store → Create New → Postgres → Continue.接受条款，为你的数据库分配一个名称，并确保你的数据库区域设置为 Washington D.C (iad1) - 这也是所有新 Vercel 项目的默认区域。通过将数据库放置在与应用程序代码相同的区域或靠近应用程序代码的区域，可以减少数据请求的延迟。需要注意的是：一旦初始化后，你无法更改数据库区域。如果你想使用不同的区域，你应该在创建数据库之前设置它。连接后，转到 .env.local 选项卡，点击 “Show secret” 并复制片段。转到你的代码编辑器，将 .env.example 文件重命名为 .env。粘贴从 Vercel 复制的内容。重要提示：进入你的 .gitignore 文件，确保 .env 是被忽略的文件之一，以防止在推送到 GitHub 时暴露你的数据库秘密。最后，在终端中运行 npm i @vercel/postgres 安装 Vercel Postgres SDK。","填充你的数据库#填充你的数据库":"既然你的数据库已经创建好了，让我们使用一些初始数据填充它。这将使你在构建 Dashboard 时有一些可用的数据。在项目的 /scripts 文件夹中，有一个名为 seed.js 的文件。这个脚本包含了创建和填充发票、客户、用户、收入表的指令。如果你不理解代码在做什么的话，不用担心，但为了给你一个概述，该脚本使用 SQL 来创建表，然后使用 placeholder-data.js 文件中的数据在表创建后填充它们。接下来，在你的 package.json 文件中，添加以下行到你的 scripts：\n\"scripts\": {\r\n  \"build\": \"next build\",\r\n  \"dev\": \"next dev\",\r\n  \"start\": \"next start\",\r\n  \"seed\": \"node -r dotenv/config ./scripts/seed.js\"\r\n},\n这是执行 seed.js 的命令。现在，运行 npm run seed。你应该在终端中看到一些 console.log 消息，让你知道脚本正在运行。\n故障排除：\n确保在将数据库秘密复制到 .env 文件之前先将其显示出来。\n脚本使用 bcrypt 对用户密码进行哈希，如果 bcrypt 与你的环境不兼容，你可以更新脚本以使用 bcryptjs。\n如果在填充数据库时遇到任何问题并希望重新运行脚本，可以通过在数据库查询界面中运行 DROP TABLE tablename 来删除任何现有表。有关更多详细信息，请参阅下面的执行查询部分。但要小心，这个命令将删除表和它们的所有数据。由于你在示例应用中使用占位数据，因此在这种情况下可以这样做，但在生产应用中不应该运行此命令。\n如果在填充你的 Vercel Postgres 数据库时继续遇到问题，请在 GitHub 上发起讨论。","浏览你的数据库#浏览你的数据库":"让我们看看你的数据库是什么样子。回到 Vercel，并点击侧边导航上的 Data。在这个部分，你会找到四个新表：users、customers、invoices 和 revenue。通过选择每个表，你可以查看其记录，并确保条目与 placeholder-data.js 文件中的数据一致。","执行查询#执行查询":"你可以切换到 “query” 选项卡与数据库进行交互。这个部分支持标准的 SQL 命令。例如，输入 DROP TABLE customers 将删除 \"customers\" 表以及所有其数据 - 所以要小心！让我们运行你的第一个数据库查询。将以下 SQL 代码粘贴并运行到 Vercel 界面中：\nSELECT invoices.amount, customers.name\r\nFROM invoices\r\nJOIN customers ON invoices.customer_id = customers.id\r\nWHERE invoices.amount = 666;","vercel-postgres-搭配本地数据库#Vercel Postgres 搭配本地数据库":"在本地开发时你可能想使用本地搭建的 Postgres 数据库，但 Vercel Postgres 目前支持的并不是特别好，详情请参见 扩展篇 1：Vercel Postgres 搭配本地数据库"}},"/chapter7":{"title":"获取数据","data":{"":"既然你已经创建并填充了你的数据库，让我们讨论一下获取应用程序数据的不同方式，以及构建 Dashboard 概览页面。以下是本章中将涵盖的主题：\n了解一些获取数据的方法：API、ORM、SQL 等。\n如何使用 Server Components 更安全地访问后端资源。\n什么是网络瀑布。\n如何使用 JavaScript 模式实现并行数据获取。","选择如何获取数据#选择如何获取数据":"","api-层#API 层":"API 是你的应用程序代码和数据库之间的中间层。有几种情况下你可能会使用 API：\n如果你使用提供 API 的第三方服务。\n如果你从客户端获取数据，你希望有一个在服务器上运行的 API 层，以避免将数据库秘密暴露给客户端。\n在 Next.js 中，你可以使用路由处理程序创建 API 端点。","数据库查询#数据库查询":"当你创建一个全栈应用程序时，你还需要编写与数据库交互的逻辑。对于像 Postgres 这样的关系数据库，你可以使用 SQL 或像 Prisma 这样的 ORM 来实现。有几种情况下你需要编写数据库查询：\n当创建 API 端点时，你需要编写与数据库交互的逻辑。\n如果你正在使用 React Server Components（在服务器上获取数据），你可以跳过 API 层，直接查询数据库，而不会有暴露数据库秘密给客户端的风险。\n让我们更深入地了解 React Server Components。","使用-server-components-获取数据#使用 Server Components 获取数据":"默认情况下，Next.js 应用程序使用 React Server Components。使用 Server Components 获取数据是一种相对较新的方法，使用它们有一些好处：\nServer Components 支持 promises，为异步任务（如数据获取）提供了更简单的解决方案。你可以使用 async/await 语法，而无需使用 useEffect、useState 或数据获取库。\nServer Components 在服务器上执行，因此你可以将昂贵的数据获取和逻辑保留在服务器上，并仅将结果发送到客户端。\n如前所述，由于 Server Components 在服务器上执行，你可以直接查询数据库，而无需额外的 API 层。","使用-sql#使用 SQL":"在你的仪表板项目中，你将使用 Vercel Postgres SDK 和 SQL 编写数据库查询。我们使用 SQL 的原因有几点：\n在关系查询数据库中 SQL 是行业标准（例如，ORM 在底层生成 SQL）。\n对 SQL 的基本理解可以帮助你理解关系数据库的基础知识，使你能够将你的知识应用于其他工具。\nSQL 是多才多艺的，允许你获取和操作特定的数据。\nVercel Postgres SDK 提供了对 SQL 注入的保护。\n如果你以前没有使用过 SQL，不用担心 - 我们已经为你提供了查询。打开 /app/lib/data.ts，这里你会看到我们正在从 @vercel/postgres 导入 sql 函数。这个函数允许你查询你的数据库：\nimport { sql } from '@vercel/postgres';\n你可以在任何 Server Component 中调用 sql。但为了让你更轻松地浏览组件，我们将所有数据查询都保留在 data.ts 文件中，你可以将它们导入到组件中。\n注意：如果在第 6 章中使用了自己的数据库提供程序，你需要更新数据库查询以适应你的提供程序。你可以在 /app/lib/data.ts 中找到这些查询。","获取-dashboard-概览页面的数据#获取 Dashboard 概览页面的数据":"既然你了解了不同的获取数据方式，让我们获取 Dashboard 概览页面的数据。导航到 /app/dashboard/page.tsx，粘贴以下代码，并花些时间来探索它：\nimport { Card } from '@/app/ui/dashboard/cards';\r\nimport RevenueChart from '@/app/ui/dashboard/revenue-chart';\r\nimport LatestInvoices from '@/app/ui/dashboard/latest-invoices';\r\nimport { lusitana } from '@/app/ui/fonts';\r\n \r\nexport default async function Page() {\r\n  return (\r\n    <main>\r\n      <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>\r\n        仪表板\r\n      </h1>\r\n      <div className=\"grid gap-6 sm:grid-cols-2 lg:grid-cols-4\">\r\n        {/* <Card title=\"已收款\" value={totalPaidInvoices} type=\"collected\" /> */}\r\n        {/* <Card title=\"待处理\" value={totalPendingInvoices} type=\"pending\" /> */}\r\n        {/* <Card title=\"总发票数\" value={numberOfInvoices} type=\"invoices\" /> */}\r\n        {/* <Card\r\n          title=\"总客户数\"\r\n          value={numberOfCustomers}\r\n          type=\"customers\"\r\n        /> */}\r\n      </div>\r\n      <div className=\"mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8\">\r\n        {/* <RevenueChart revenue={revenue}  /> */}\r\n        {/* <LatestInvoices latestInvoices={latestInvoices} /> */}\r\n      </div>\r\n    </main>\r\n  );\r\n}\n在上面的代码中：\nPage 是一个异步组件。这允许你使用 await 来获取数据。\n还有 3 个组件接收数据：<Card>、<RevenueChart> 和 <LatestInvoices>。它们当前被注释掉，以防止应用程序出错。","获取-revenuechart-组件的数据#获取 <RevenueChart/> 组件的数据":"要获取 <RevenueChart/> 组件的数据，从 data.ts 中导入 fetchRevenue 函数，并在你的组件内调用它：\nimport { Card } from '@/app/ui/dashboard/cards';\r\nimport RevenueChart from '@/app/ui/dashboard/revenue-chart';\r\nimport LatestInvoices from '@/app/ui/dashboard/latest-invoices';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport { fetchRevenue } from '@/app/lib/data';\r\n \r\nexport default async function Page() {\r\n  const revenue = await fetchRevenue();\r\n  // ...\r\n}\n然后，取消注释 <RevenueChart/> 组件，导航到组件文件（/app/ui/dashboard/revenue-chart.tsx）并取消注释其中的代码。检查你的 localhost，你应该能够看到一个使用收入数据的图表。让我们继续导入更多的数据查询！","获取-latestinvoices--组件的数据#获取 <LatestInvoices /> 组件的数据":"对于 <LatestInvoices /> 组件，我们需要获取最新的 5 张发票，并按日期排序。你可以获取所有的发票，然后使用 JavaScript 进行排序。这对于我们的小型数据来说不是问题，但随着应用程序的增长，它可能会显著增加每个请求传输的数据量和用于排序的 JavaScript。与在内存中对最新发票进行排序不同，你可以使用 SQL 查询仅获取最近的 5 张发票。例如，这是你的 data.ts 文件中的 SQL 查询：\n// 获取最近的 5 张发票，按日期排序\r\nconst data = await sql<LatestInvoiceRaw>`\r\n  SELECT invoices.amount, customers.name, customers.image_url, customers.email\r\n  FROM invoices\r\n  JOIN customers ON invoices.customer_id = customers.id\r\n  ORDER BY invoices.date DESC\r\n  LIMIT 5`;\n在你的页面中，导入 fetchLatestInvoices 函数：\nimport { Card } from '@/app/ui/dashboard/cards';\r\nimport RevenueChart from '@/app/ui/dashboard/revenue-chart';\r\nimport LatestInvoices from '@/app/ui/dashboard/latest-invoices';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport { fetchRevenue, fetchLatestInvoices } from '@/app/lib/data';\r\n \r\nexport default async function Page() {\r\n  const revenue = await fetchRevenue();\r\n  const latestInvoices = await fetchLatestInvoices();\r\n  // ...\r\n}\n然后，取消注释 <LatestInvoices /> 组件。你还需要在 <LatestInvoices /> 组件本身（位于 /app/ui/dashboard/latest-invoices）中取消注释相关代码。如果你访问 localhost，你应该会看到只有最近的 5 张发票从数据库返回。希望你开始看到直接查询数据库的优势了！","练习为-card-组件获取数据#练习：为 <Card> 组件获取数据":"现在轮到你为 <Card> 组件获取数据了。卡片将显示以下数据：\n已收款的发票总额。\n待处理的发票总额。\n发票的总数。\n客户的总数。\n再次，你可能会诱惑地获取所有发票和客户，并使用 JavaScript 操纵数据。例如，你可以使用 Array.length 来获取发票和客户的总数：\nconst totalInvoices = allInvoices.length;\r\nconst totalCustomers = allCustomers.length;\n但是使用 SQL，你可以仅获取需要的数据。虽然使用 Array.length 要短一些，但这意味着在请求期间需要传输的数据较少。这是 SQL 的替代方法：\nconst invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;\r\nconst customerCountPromise = sql`SELECT COUNT(*) FROM customers`;\n你需要导入的函数叫做 fetchCardData。你需要解构函数返回的值。提示：\n检查卡片组件，看看它们需要什么数据。\n检查 data.ts 文件，看看该函数返回什么。\n当你准备好后，展开下面的切换以查看最终代码：\n点击展开/折叠\n  import { Card } from '@/app/ui/dashboard/cards';\r\n  import RevenueChart from '@/app/ui/dashboard/revenue-chart';\r\n  import LatestInvoices from '@/app/ui/dashboard/latest-invoices';\r\n  import { lusitana } from '@/app/ui/fonts';\r\n  import {\r\n    fetchRevenue,\r\n    fetchLatestInvoices,\r\n    fetchCardData,\r\n  } from '@/app/lib/data';\r\n  \r\n  export default async function Page() {\r\n    const revenue = await fetchRevenue();\r\n    const latestInvoices = await fetchLatestInvoices();\r\n    const {\r\n      numberOfInvoices,\r\n      numberOfCustomers,\r\n      totalPaidInvoices,\r\n      totalPendingInvoices,\r\n    } = await fetchCardData();\r\n  \r\n    return (\r\n      <main>\r\n        <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>\r\n          Dashboard\r\n        </h1>\r\n        <div className=\"grid gap-6 sm:grid-cols-2 lg:grid-cols-4\">\r\n          <Card title=\"Collected\" value={totalPaidInvoices} type=\"collected\" />\r\n          <Card title=\"Pending\" value={totalPendingInvoices} type=\"pending\" />\r\n          <Card title=\"Total Invoices\" value={numberOfInvoices} type=\"invoices\" />\r\n          <Card\r\n            title=\"Total Customers\"\r\n            value={numberOfCustomers}\r\n            type=\"customers\"\r\n          />\r\n        </div>\r\n        <div className=\"mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8\">\r\n          <RevenueChart revenue={revenue} />\r\n          <LatestInvoices latestInvoices={latestInvoices} />\r\n        </div>\r\n      </main>\r\n    );\r\n  }\n太好了！你现在已经为仪表板概览页面获取了所有数据。你的页面应该看起来像这样：然而...有两件事情需要注意：\n数据请求无意中相互阻塞，形成请求瀑布。\n默认情况下，Next.js 对路由进行预渲染以提高性能，这称为静态渲染。因此，如果你的数据发生变化，它不会反映在你的 Dashboard 中。\n让我们在本章中讨论第一点，然后在下一章详细了解第二点。","请求瀑布是什么#请求瀑布是什么？":"\"瀑布\" 指的是一系列的网络请求序列，这些请求依赖于前面请求的完成。在数据获取的情况下，每个请求只能在前一个请求返回数据后才能开始。例如，我们需要等待 fetchRevenue() 执行完毕，然后 fetchLatestInvoices() 才能开始运行，以此类推。\nconst revenue = await fetchRevenue();\r\nconst latestInvoices = await fetchLatestInvoices(); // 等待 fetchRevenue() 完成\r\nconst {\r\n  numberOfInvoices,\r\n  numberOfCustomers,\r\n  totalPaidInvoices,\r\n  totalPendingInvoices,\r\n} = await fetchCardData(); // 等待 fetchLatestInvoices() 完成\n这种模式不一定是不好的。有些情况下，你可能希望有瀑布，因为你希望在进行下一个请求之前满足某个条件。例如，你可能希望先获取用户的 ID 和个人资料信息。一旦有了 ID，你可能会继续获取他们的朋友列表。在这种情况下，每个请求都依赖于前一个请求返回的数据。然而，这种行为也可能是无意的，并且会影响性能。","并行数据获取#并行数据获取":"避免瀑布的一种常见方式是同时启动所有数据请求 - 进行并行处理。在 JavaScript 中，您可以使用 Promise.all() 或 Promise.allSettled() 函数同时启动所有 Promise。例如，在 data.ts 中，我们在 fetchCardData() 函数中使用了 Promise.all()：\nexport async function fetchCardData() {\r\n  try {\r\n    const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;\r\n    const customerCountPromise = sql`SELECT COUNT(*) FROM customers`;\r\n    const invoiceStatusPromise = sql`SELECT\r\n         SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) AS \"paid\",\r\n         SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS \"pending\"\r\n         FROM invoices`;\r\n \r\n    const data = await Promise.all([\r\n      invoiceCountPromise,\r\n      customerCountPromise,\r\n      invoiceStatusPromise,\r\n    ]);\r\n    // ...\r\n  }\r\n}\n通过使用这种模式，您可以：\n同时开始执行所有数据获取，这可能会带来性能提升。\n使用可应用于任何库或框架的本机 JavaScript 模式。\n然而，仅依赖此 JavaScript 模式有一个缺点：如果一个数据请求比其他所有请求慢，会发生什么？"}},"/chapter9":{"title":"流式传输","data":{"":"在上一章中，您使得 Dashboard 页面变得动态化，然而，我们讨论了慢速数据获取如何影响应用程序性能的问题。让我们看看在存在慢速数据请求时如何改善用户体验。以下是本章中将涵盖的主题：\n什么是流式传输以及何时可能使用它。\n如何使用 loading.tsx 和 Suspense 实现流式传输。\n什么是加载骨架。\n什么是路由组，以及何时可能使用它们。\n在应用程序中放置 Suspense 边界的位置。","什么是流式传输#什么是流式传输？":"流式传输是一种数据传输技术，允许您将路由分解为较小的 “chunks（块）”，并在它们准备就绪时逐步从服务器流式传输到客户端。通过流式传输，您可以防止慢速数据请求阻塞整个页面。这允许用户在等待所有数据加载之前看到和与页面的某些部分交互，而无需等待在向用户显示任何 UI 之前加载所有数据。流式传输在 React 的组件模型中表现良好，因为可以将每个组件视为一个块。在 Next.js 中，有两种实现流式传输的方式：\n在页面级别，使用 loading.tsx 文件。\n对于特定组件，使用 <Suspense>。\n让我们看看这是如何工作的。","使用-loadingtsx-流式传输整个页面#使用 loading.tsx 流式传输整个页面":"在 /app/dashboard 文件夹中，创建一个名为 loading.tsx 的新文件：\nexport default function Loading() {\r\n  return <div>Loading...</div>;\r\n}\n刷新 http://localhost:3000/dashboard， 您现在应该会看到：这里发生了一些事情：\nloading.tsx 是一个基于 Suspense 构建的特殊 Next.js 文件，它允许您创建回退 UI，以在页面内容加载时显示为替代。\n由于 <Sidebar> 是静态的，因此它会立即显示。用户可以在动态内容加载时与 <Sidebar> 进行交互。\n用户在导航离开之前不必等待页面完成加载（这称为可中断导航）。\n恭喜！您刚刚实现了流式传输。但我们可以做更多来改善用户体验。让我们显示一个加载骨架，而不是 Loading... 文本。","添加加载骨架#添加加载骨架":"加载骨架是 UI 的简化版本。许多网站将它们用作占位符（或备用），以指示用户内容正在加载。您嵌入到 loading.tsx 中的任何 UI 都将作为静态文件的一部分嵌入并首先发送。然后，服务器将其余的动态内容从服务器流式传输到客户端。在您的 loading.tsx 文件中，导入一个名为 <DashboardSkeleton> 的新组件：\nimport DashboardSkeleton from '@/app/ui/skeletons';\r\n \r\nexport default function Loading() {\r\n  return <DashboardSkeleton />;\r\n}\n然后，刷新 http://localhost:3000/dashboard， 您现在应该会看到：","修复使用路由组的加载骨架错误#修复使用路由组的加载骨架错误":"当前，您的加载骨架也会应用于发票和客户页面。由于 loading.tsx 处于文件系统中 /invoices/page.tsx 和 /customers/page.tsx 的上一级，它也应用于这些页面。我们可以通过使用路由组来更改这一点。在 dashboard 文件夹内创建一个名为 /(overview) 的新文件夹。然后，将您的 loading.tsx 和 page.tsx 文件移到该文件夹内：现在，loading.tsx 文件将仅适用于您的 Dashboard 概览页面。路由组允许您将文件组织成逻辑组，而不影响 URL 路径结构。当您使用括号 () 创建一个新文件夹时，该名称将不包括在 URL 路径中。因此，/dashboard/(overview)/page.tsx 变成了 /dashboard。在这里，您使用了一个路由组来确保 loading.tsx 仅适用于您的仪表板概览页面。但是，您还可以使用路由组将应用程序分成不同的部分（例如 (marketing) 路由和 (shop) 路由），或者按团队对更大的应用程序进行组织。","流式传输一个组件#流式传输一个组件":"到目前为止，您一直在流式传输整个页面。但是，相反，您可以更加细致，并使用 React Suspense 流式传输特定组件。Suspense 允许您推迟呈现应用程序的某些部分，直到满足某些条件（例如加载数据）。您可以在 Suspense 中包装动态组件。然后，传递一个回退组件，以在动态组件加载时显示。如果您记得慢数据请求 fetchRevenue()，这是减缓整个页面速度的请求。您可以使用 Suspense 来流式传输仅此组件，并立即显示页面其余的 UI，而不是阻塞整个页面。要这样做，您需要将数据获取移至组件内部，让我们更新代码看看会是什么样子：删除 /dashboard/(overview)/page.tsx 中的 fetchRevenue() 及其数据的所有实例：\nimport { Card } from '@/app/ui/dashboard/cards';\r\nimport RevenueChart from '@/app/ui/dashboard/revenue-chart';\r\nimport LatestInvoices from '@/app/ui/dashboard/latest-invoices';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport { fetchLatestInvoices, fetchCardData } from '@/app/lib/data'; // 删除 fetchRevenue\r\n \r\nexport default async function Page() {\r\n  const revenue = await fetchRevenue // 删除这一行\r\n  const latestInvoices = await fetchLatestInvoices();\r\n  const {\r\n    numberOfInvoices,\r\n    numberOfCustomers,\r\n    totalPaidInvoices,\r\n    totalPendingInvoices,\r\n  } = await fetchCardData();\r\n \r\n  return (\r\n    // ...\r\n  );\r\n}\n然后，从 React 中导入 <Suspense>，并将其包装在 <RevenueChart /> 周围。您可以传递一个名为 <RevenueChartSkeleton> 的回退组件。\nimport { Card } from '@/app/ui/dashboard/cards';\r\nimport RevenueChart from '@/app/ui/dashboard/revenue-chart';\r\nimport LatestInvoices from '@/app/ui/dashboard/latest-invoices';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport { fetchLatestInvoices, fetchCardData } from '@/app/lib/data';\r\nimport { Suspense } from 'react';\r\nimport { RevenueChartSkeleton } from '@/app/ui/skeletons';\r\n \r\nexport default async function Page() {\r\n  const latestInvoices = await fetchLatestInvoices();\r\n  const {\r\n    numberOfInvoices,\r\n    numberOfCustomers,\r\n    totalPaidInvoices,\r\n    totalPendingInvoices,\r\n  } = await fetchCardData();\r\n \r\n  return (\r\n    <main>\r\n      <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>\r\n        Dashboard\r\n      </h1>\r\n      <div className=\"grid gap-6 sm:grid-cols-2 lg:grid-cols-4\">\r\n        <Card title=\"Collected\" value={totalPaidInvoices} type=\"collected\" />\r\n        <Card title=\"Pending\" value={totalPendingInvoices} type=\"pending\" />\r\n        <Card title=\"Total Invoices\" value={numberOfInvoices} type=\"invoices\" />\r\n        <Card\r\n          title=\"Total Customers\"\r\n          value={numberOfCustomers}\r\n          type=\"customers\"\r\n        />\r\n      </div>\r\n      <div className=\"mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8\">\r\n        <Suspense fallback={<RevenueChartSkeleton />}>\r\n          <RevenueChart />\r\n        </Suspense>\r\n        <LatestInvoices latestInvoices={latestInvoices} />\r\n      </div>\r\n    </main>\r\n  );\r\n}\n最后，更新 <RevenueChart> 组件以获取其自己的数据，并删除传递给它的 prop：\nimport { generateYAxis } from '@/app/lib/utils';\r\nimport { CalendarIcon } from '@heroicons/react/24/outline';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport { fetchRevenue } from '@/app/lib/data';\r\n \r\n// ...\r\n \r\nexport default async function RevenueChart() { // 使组件异步，删除 props\r\n  const revenue = await fetchRevenue(); // 在组件内获取数据\r\n \r\n  const chartHeight = 350;\r\n  const { yAxisLabels, topLabel } = generateYAxis(revenue);\r\n \r\n  if (!revenue || revenue.length === 0) {\r\n    return <p className=\"mt-4 text-gray-400\">No data available.</p>;\r\n  }\r\n \r\n  return (\r\n    // ...\r\n  );\r\n}\n现在刷新页面，您应该会看到几乎立即显示仪表板信息，而 <RevenueChart> 显示为回退骨架：","练习流式传输-latestinvoices#练习：流式传输 <LatestInvoices>":"现在轮到你了！通过流式传输 <LatestInvoices> 组件来实践刚学到的内容。将 fetchLatestInvoices() 从页面下移至 <LatestInvoices> 组件。使用名为 <LatestInvoicesSkeleton> 的回退 （fallback） 包装该组件。当你准备好时，展开切换以查看解决方案代码：\n点击展开/折叠\nDashboard Page:\n  import { Card } from '@/app/ui/dashboard/cards';\r\n  import RevenueChart from '@/app/ui/dashboard/revenue-chart';\r\n  import LatestInvoices from '@/app/ui/dashboard/latest-invoices';\r\n  import { lusitana } from '@/app/ui/fonts';\r\n  import { fetchCardData } from '@/app/lib/data'; // Remove fetchLatestInvoices\r\n  import { Suspense } from 'react';\r\n  import {\r\n    RevenueChartSkeleton,\r\n    LatestInvoicesSkeleton,\r\n  } from '@/app/ui/skeletons';\r\n  \r\n  export default async function Page() {\r\n    // Remove `const latestInvoices = await fetchLatestInvoices()`\r\n    const {\r\n      numberOfInvoices,\r\n      numberOfCustomers,\r\n      totalPaidInvoices,\r\n      totalPendingInvoices,\r\n    } = await fetchCardData();\r\n  \r\n    return (\r\n      <main>\r\n        <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>\r\n          Dashboard\r\n        </h1>\r\n        <div className=\"grid gap-6 sm:grid-cols-2 lg:grid-cols-4\">\r\n          <Card title=\"Collected\" value={totalPaidInvoices} type=\"collected\" />\r\n          <Card title=\"Pending\" value={totalPendingInvoices} type=\"pending\" />\r\n          <Card title=\"Total Invoices\" value={numberOfInvoices} type=\"invoices\" />\r\n          <Card\r\n            title=\"Total Customers\"\r\n            value={numberOfCustomers}\r\n            type=\"customers\"\r\n          />\r\n        </div>\r\n        <div className=\"mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8\">\r\n          <Suspense fallback={<RevenueChartSkeleton />}>\r\n            <RevenueChart />\r\n          </Suspense>\r\n          <Suspense fallback={<LatestInvoicesSkeleton />}>\r\n            <LatestInvoices />\r\n          </Suspense>\r\n        </div>\r\n      </main>\r\n    );\r\n  }\n<LatestInvoices> 组件。记得删除 props！\nimport { ArrowPathIcon } from '@heroicons/react/24/outline';\r\nimport clsx from 'clsx';\r\nimport Image from 'next/image';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport { fetchLatestInvoices } from '@/app/lib/data';\r\n\r\nexport default async function LatestInvoices() { // Remove props\r\n  const latestInvoices = await fetchLatestInvoices();\r\n\r\n  return (\r\n    // ...\r\n  );\r\n}","组件分组#组件分组":"太好了！你已经接近成功，现在你需要将 <Card> 组件包装在 Suspense 中。虽然你可以为每个单独的卡片获取数据，但这可能会导致卡片加载时出现弹出效果，这对用户来说可能是视觉上的冲击。那么，你会如何解决这个问题呢？为了创建更具阶梯效果，你可以使用一个包装组件来组织这些卡片。这意味着静态的 <Sidebar/> 会首先显示，然后是卡片，依此类推。在你的 page.tsx 文件中：\n删除 <Card> 组件。\n删除 fetchCardData() 函数。\n导入一个名为 <CardWrapper /> 的新包装组件。\n导入一个名为 <CardsSkeleton /> 的新骨架组件。\n使用 Suspense 包装 <CardWrapper />。\nimport CardWrapper from '@/app/ui/dashboard/cards';\r\n// ...\r\nimport {\r\n  RevenueChartSkeleton,\r\n  LatestInvoicesSkeleton,\r\n  CardsSkeleton,\r\n} from '@/app/ui/skeletons';\r\n \r\nexport default async function Page() {\r\n  return (\r\n    <main>\r\n      <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>\r\n        Dashboard\r\n      </h1>\r\n      <div className=\"grid gap-6 sm:grid-cols-2 lg:grid-cols-4\">\r\n        <Suspense fallback={<CardsSkeleton />}>\r\n          <CardWrapper />\r\n        </Suspense>\r\n      </div>\r\n      // ...\r\n    </main>\r\n  );\r\n}\n然后，进入 /app/ui/dashboard/cards.tsx 文件，导入 fetchCardData() 函数，并在 <CardWrapper/> 组件内调用它。确保在此组件中取消注释任何必要的代码。\n// ...\r\nimport { fetchCardData } from '@/app/lib/data';\r\n \r\n// ...\r\n \r\nexport default async function CardWrapper() {\r\n  const {\r\n    numberOfInvoices,\r\n    numberOfCustomers,\r\n    totalPaidInvoices,\r\n    totalPendingInvoices,\r\n  } = await fetchCardData();\r\n \r\n  return (\r\n    <>\r\n      <Card title=\"Collected\" value={totalPaidInvoices} type=\"collected\" />\r\n      <Card title=\"Pending\" value={totalPendingInvoices} type=\"pending\" />\r\n      <Card title=\"Total Invoices\" value={numberOfInvoices} type=\"invoices\" />\r\n      <Card\r\n        title=\"Total Customers\"\r\n        value={numberOfCustomers}\r\n        type=\"customers\"\r\n      />\r\n    </>\r\n  );\r\n}\n刷新页面，你应该会看到所有的卡片同时加载。当你希望多个组件同时加载时，可以使用这种模式。","决定放置-suspense-边界的位置#决定放置 Suspense 边界的位置":"放置 Suspense 边界的位置取决于几个因素：\n您希望用户在页面流式传输时如何体验。\n您希望优先考虑哪些内容。\n组件是否依赖于数据获取。\n看看您的 Dashboard 页面，有没有什么您会做得不同的？别担心。没有一个正确的答案。\n您可以像我们在 loading.tsx 中所做的那样流式传输整个页面... 但如果其中一个组件具有较慢的数据获取，这可能会导致较长的加载时间。\n您可以逐个流式传输每个组件... 但这可能会导致UI在准备就绪时突然出现在屏幕上。\n您还可以通过流式传输页面部分来创建错开效果。但您需要创建包装组件。\n放置 suspense 边界的位置将取决于您的应用程序。总的来说，将数据获取移到需要它的组件中，然后在这些组件周围包装 Suspense 是一种良好的实践。但是，如果您的应用程序需要，将整个页面或部分页面进行流式传输也没有问题。不要害怕尝试使用 Suspense，看看哪种方法最有效，它是一个强大的 API，可以帮助您创建更令人愉悦的用户体验。","展望未来#展望未来":"流式传输和服务器组件为我们处理数据获取和加载状态提供了新的方式，最终目标是改善最终用户体验。在下一章中，您将了解到 “部分预渲染”（Partial Prerendering），这是一种专为流式传输而构建的新的 Next.js 渲染模型。"}},"/chapter4":{"title":"创建 Layouts 和 Pages","data":{"":"到目前为止，你的应用只有一个主页。让我们学习如何使用布局和页面创建更多路由。以下是本章中将涵盖的主题：\n使用文件系统路由创建仪表板路由。\n了解在创建新路由段时文件夹和文件的作用。\n创建一个可以在多个仪表板页面之间共享的嵌套布局。\n了解放置同位置、部分渲染和根布局的作用。","嵌套路由#嵌套路由":"Next.js 使用文件系统路由，其中文件夹用于创建嵌套路由。每个文件夹代表一个路由段，对应到一个 URL 段。图示展示了文件夹如何映射到 URL 段你可以使用 layout.tsx 和 page.tsx 文件为每个路由创建单独的用户界面。page.tsx 是 Next.js 的一个特殊文件，它导出一个 React 组件，让该路由可访问是必需的。在你的应用中，已经有一个页面文件：/app/page.tsx - 这是与路由 / 相关联的主页。要创建嵌套路由，可以将文件夹嵌套在彼此之内，并在其中添加 page.tsx 文件。例如：/app/dashboard/page.tsx 与路径 /dashboard 相关联。让我们创建页面看看它是如何工作的！","创建-dashboard-页面#创建 Dashboard 页面":"在 /app 中创建一个名为 dashboard 的新文件夹。然后，在 dashboard 文件夹内创建一个名为 page.tsx 的新文件，其内容如下：\nexport default function Page() {\r\n  return <p>Dashboard Page</p>;\r\n}\n现在，确保开发服务器正在运行，并访问 http://localhost:3000/dashboard。 你应该看到 \"Dashboard Page\" 文本。这就是在 Next.js 中创建不同页面的方式：使用文件夹创建新的路由段，并在其中添加一个 page 文件。通过为页面文件使用特殊的名称，Next.js 允许你将 UI 组件、测试文件和其他相关代码与路由放置在一起。只有页面文件内部的内容才会被公开访问。例如，/ui 和 /lib 文件夹与你的路由一起放置在 /app 文件夹中。","实践创建仪表板页面#实践：创建仪表板页面":"让我们练习创建更多的路由。在你的 dashboard 中，创建两个额外的页面：\n顾客页面（Customers Page）：该页面应该在 http://localhost:3000/dashboard/customers 上可访问。暂时返回一个 <p>Customers Page</p> 元素。\n发票页面（Invoices Page）：发票页面应该在 http://localhost:3000/dashboard/invoices 上可访问。暂时也返回一个 <p>Invoices Page</p> 元素。\n花点时间解决这个练习，当你准备好时，展开下面的切换查看解决方案：\n点击展开/折叠\nCustomers Page:\nexport default function Page() {\r\n  return <p>Customers Page</p>;\r\n}\nInvoices Page:\nexport default function Page() {\r\n  return <p>Invoices Page</p>;\r\n}","创建-dashboard-布局#创建 dashboard 布局":"dashboard 通常具有在多个页面之间共享的导航。在 Next.js 中，你可以使用一个特殊的 layout.tsx 文件来创建在多个页面之间共享的 UI。让我们为 dashboard 页面创建一个布局！在 /dashboard 文件夹中，添加一个名为 layout.tsx 的新文件，并粘贴以下代码：\nimport SideNav from '@/app/ui/dashboard/sidenav';\r\n \r\nexport default function Layout({ children }: { children: React.ReactNode }) {\r\n  return (\r\n    <div className=\"flex h-screen flex-col md:flex-row md:overflow-hidden\">\r\n      <div className=\"w-full flex-none md:w-64\">\r\n        <SideNav />\r\n      </div>\r\n      <div className=\"flex-grow p-6 md:overflow-y-auto md:p-12\">{children}</div>\r\n    </div>\r\n  );\r\n}\n这段代码中发生了一些事情，让我们来详细解释一下：首先，你将 <SideNav /> 组件导入到你的布局中。你导入到这个文件中的任何组件都将成为布局的一部分。<Layout /> 组件接收一个 children 属性。这个子组件可以是一个页面或另一个布局。在你的情况下，位于 /dashboard 中的页面将自动嵌套在 <Layout /> 中，如下所示：检查一切是否正确运行，保存你的更改并检查你的本地主机。你应该会看到以下内容：在 Next.js 中使用布局的一个好处是，在导航时，只有页面组件会更新，而布局不会重新渲染。这被称为部分渲染。","根布局layout#根布局（layout）":"在第三章中，你将 Inter 字体引入到另一个布局中：/app/layout.tsx。作为提醒：\nimport '@/app/ui/global.css';\r\nimport { inter } from '@/app/ui/fonts';\r\n \r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode;\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body className={`${inter.className} antialiased`}>{children}</body>\r\n    </html>\r\n  );\r\n}\n这被称为根布局，是必需的。你添加到根布局的任何 UI 将在应用程序中的所有页面之间共享。你可以使用根布局来修改 <html> 和 <body> 标签，添加元数据（关于元数据的更多内容将在后面的章节中学到）。由于你刚刚创建的新布局（/app/dashboard/layout.tsx）专门用于 dashboard 页面，因此不需要在上述根布局中添加任何 UI。"}},"/":{"title":"欢迎来到 Learn Next.js 中文教程","data":{"":"Next.js v14 版本发布时，除了正常的版本更新之外，还发布了一个基于 App Router 架构的免费学习教程，通过构建全栈 Web 应用程序，可以让您更好的了解 Next.js 的主要功能。本系列是基于官方教程的一个中文翻译版本。在翻译、整理的过程中，每个章节对应的 Example 代码，笔者也都进行了测试，有问题的部分也进行了修改，参见 Github 项目 nextjs-learn-example。","我们将要做的#我们将要做的":"在这个课程中，我们将构建一个财务 Dashboard 的简化版本，其中包含以下内容：\n一个公共首页。\n一个登录页面。\n受身份验证保护的仪表板页面。\n用户能够添加、编辑和删除发票。\n该 Dashboard 还将有一个相应的数据库，在后面的章节中将对其进行设置。通过本课程，您将掌握构建全栈 Next.js 应用程序所需的基本技能。","概述#概述":"以下是本课程中您将学到的功能：\nStyling（样式化）： 在 Next.js 中样式化应用程序的不同方法。\nOptimizations（优化）： 如何优化图像、链接和字体。\nRouting（路由）： 使用文件系统路由创建嵌套布局和页面。\nData Fetching（数据获取）： 如何在 Vercel 上设置数据库，以及获取和流式传输的最佳实践。\nSearch and Pagination（搜索和分页）： 如何使用 URL 搜索参数实现搜索和分页。\nMutating Data（数据突变）： 如何使用 React Server Actions 操作数据，并重新验证 Next.js 缓存。\nError Handling（错误处理）： 如何处理一般错误和 404 未找到错误。\nForm Validation and Accessibility（表单验证和可访问性）： 如何进行服务器端表单验证以及提高可访问性的提示。\nAuthentication（身份验证）： 如何使用 NextAuth.js 和中间件为应用程序添加身份验证。\nMetadata（元数据）： 如何添加元数据并为社交分享准备您的应用程序。","先决知识#先决知识":"本课程假设您对 React 和 JavaScript 有基本的了解。如果您是 React 的新手，我们建议您首先完成我们的 React 基础课程，以学习 React 的基础知识，如组件、props、state 和 hooks，以及像 Server Components 和 Suspense 这样的新功能。","系统要求#系统要求":"在开始本课程之前，请确保您的系统满足以下要求：\n安装 Node.js 18.17.0 或更高版本。下载地址\n操作系统：macOS、Windows（包括WSL）或Linux。\n另外，您还需要一个 GitHub 账号和一个 Vercel 账号。（Vercel 是用来部署用的，如果服务只是在本地运行，做为学习使用，Vercel 账号也不是必须的）。","加入讨论#加入讨论":"如果您对本课程有疑问或想提供反馈，您可以通过以下渠道提问：\nNext.js Discord\nnext-learn GitHub 。\n如果你发现翻译的文档中有任何问题，欢迎指出！想加入 Next.js 技术交流群的请扫描下方二维码先添加作者 “五月君” 微信，备注：nextjs。同时也欢迎关注公众号「编程界」获取最新 Next.js 开发资讯！\n如果本教程能为您得到帮助，请给予项目 Learn Next.js 中文教程 一个 ★ 做为支持！"}},"/chapter16":{"title":"添加元数据（Metadata）","data":{"":"元数据对于 SEO 和可共享性至关重要。在本章中，我们将讨论如何向你的 Next.js 应用程序添加元数据。以下是本章中将涵盖的主题：\n什么是元数据。\n元数据的类型。\n如何使用元数据添加 Open Graph 图像。\n如何使用元数据添加 favicon。","什么是元数据#什么是元数据？":"在 Web 开发中，元数据提供有关网页的其他详细信息。元数据对于访问页面的用户来说是不可见的。相反，它在幕后工作，嵌入在页面的 HTML 中，通常位于 <head> 元素内。这些隐藏的信息对于搜索引擎和其他需要更好了解你的网页内容的系统非常重要。","为什么元数据很重要#为什么元数据很重要？":"元数据在增强网页的 SEO 方面起着重要作用，使其对搜索引擎和社交媒体平台更易访问和理解。正确的元数据有助于搜索引擎有效地索引网页，提高其在搜索结果中的排名。此外，像 Open Graph 这样的元数据提高了应用在社交媒体上的外观，使其更具吸引力。","元数据类型#元数据类型":"有各种各样的元数据类型，每种都具有独特的目的。一些常见的类型包括：标题元数据（Title Metadata）：负责显示在浏览器标签上的网页标题。对于 SEO 来说非常关键，因为它帮助搜索引擎了解网页的主题。\n<title>Page Title</title>\n描述元数据（Description Metadata）：提供对网页内容的简要概述，通常显示在搜索引擎结果中。\n<meta name=\"description\" content=\"A brief description of the page content.\" />\n关键字元数据（Keyword Metadata）：包括与网页内容相关的关键字，帮助搜索引擎索引页面。\n<meta name=\"keywords\" content=\"keyword1, keyword2, keyword3\" />\nOpen Graph 元数据（Open Graph Metadata）：当在社交媒体平台上分享时，此元数据增强了网页的表示，提供标题、描述和预览图像等信息。\n<meta property=\"og:title\" content=\"Title Here\" />\r\n<meta property=\"og:description\" content=\"Description Here\" />\r\n<meta property=\"og:image\" content=\"image_url_here\" />\nFavicon 元数据（Favicon Metadata）：将网页的图标（小图标）链接到网页，显示在浏览器的地址栏或标签中。\n<link rel=\"icon\" href=\"path/to/favicon.ico\" />","添加元数据#添加元数据":"Next.js 提供了一个 Metadata API，可用于定义应用程序的元数据。有两种方法可以向应用程序添加元数据：\n基于配置：在 layout.js 或 page.js 文件中导出一个静态的 metadata 对象或一个动态的 generateMetadata 函数。\n基于文件：Next.js 有一系列专门用于元数据目的的特殊文件：\nfavicon.ico、apple-icon.jpg 和 icon.jpg：用于 favicon 和图标\nopengraph-image.jpg 和 twitter-image.jpg：用于社交媒体图片\nrobots.txt：提供搜索引擎爬取的指令\nsitemap.xml：提供有关网站结构的信息\n您可以灵活使用这些文件进行静态元数据，或者可以在项目中以编程方式生成它们。使用这两种选项，Next.js 将自动为您的页面生成相关的 <head> 元素。","favicon-和-open-graph-图像#Favicon 和 Open Graph 图像":"在 /public 文件夹中，您会注意到有两个图像：favicon.ico 和 opengraph-image.jpg。将这些图像移动到 /app 文件夹的根目录。这样做后，Next.js 将自动识别并使用这些文件作为您的 favicon 和 OG 图像。您可以通过在 dev 工具中检查应用程序的 <head> 元素来验证这一点。需要注意的是：您还可以使用 ImageResponse 构造函数创建动态 OG 图像。","页面标题和描述#页面标题和描述":"您还可以从任何 layout.js 或 page.js 文件中包含一个 metadata 对象，以添加额外的页面信息，如标题和描述。在 layout.js 中的任何元数据都将被使用它的所有页面继承。在根布局中，创建一个新的 metadata 对象，具有以下字段：\nimport { Metadata } from 'next';\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'Acme Dashboard',\r\n  description: 'The official Next.js Course Dashboard, built with App Router.',\r\n  metadataBase: new URL('https://next-learn-dashboard.vercel.sh'),\r\n};\r\n\r\nexport default function RootLayout() {\r\n  // ...\r\n}\nNext.js 将自动将标题和元数据添加到您的应用程序。但是，如果您想为特定页面添加自定义标题怎么办？您可以通过向页面本身添加 metadata 对象来实现这一点。嵌套页面中的元数据将覆盖父级中的元数据。例如，在 /dashboard/invoices 页面中，您可以更新页面标题：\nimport { Metadata } from 'next';\r\n\r\nexport const metadata: Metadata = {\r\n  title: 'Invoices | Acme Dashboard',\r\n};\n这样做是有效的，但我们在每个页面上都重复了应用程序的标题。如果发生更改，例如公司名称，您将不得不在每个页面上进行更新。相反，您可以使用 metadata 对象中的 title.template 字段来为页面标题定义模板。此模板可以包含页面标题以及其他您想包含的信息。在根布局中，更新 metadata 对象以包含一个模板：\nimport { Metadata } from 'next';\r\n\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    template: '%s | Acme Dashboard',\r\n    default: 'Acme Dashboard',\r\n  },\r\n  description: 'The official Next.js Learn Dashboard built with App Router.',\r\n  metadataBase: new URL('https://next-learn-dashboard.vercel.sh'),\r\n};\n模板中的 %s 将替换为特定的页面标题。现在，在 /dashboard/invoices 页面中，您可以添加页面标题：\nexport const metadata: Metadata = {\r\n  title: 'Invoices',\r\n};\n转到 /dashboard/invoices 页面并检查 <head> 元素。您应该看到页面标题现在是 Invoices | Acme Dashboard。","练习添加元数据#练习：添加元数据":"现在您已经了解了元数据，通过为其他页面添加标题进行练习：\n/login page.\n/dashboard/ page.\n/dashboard/customers page.\n/dashboard/invoices/create page.\n/dashboard/invoices/[id]/edit page.\nNext.js 的 Metadata API 功能强大且灵活，使您可以完全掌控应用程序的元数据。在这里，我们向您展示了如何添加一些基本的元数据，但您可以添加多个字段，包括 keywords、robots、canonical 等。请随意查阅文档，并向您的应用程序添加任何额外的元数据。"}},"/chapter15":{"title":"添加身份验证","data":{"":"在前一章中，通过添加 form 验证和改善可访问性，你完成了构建发票路由的过程。在这一章中，你将为 dashboard 添加身份验证。以下是本章中将涵盖的主题：\n什么是身份验证。\n如何使用 NextAuth.js 为应用添加身份验证。\n如何使用中间件重定向用户并保护你的路由。\n如何使用 React 的 useFormStatus 和 useFormState 处理 pending 状态和 form 错误。","什么是身份验证#什么是身份验证？":"身份验证是当今许多 Web 应用程序的关键部分。这是系统检查用户是否是他们所说的那个人的方式。一个安全的网站通常使用多种方法来检查用户的身份。例如，在输入用户名和密码后，网站可能会向你的设备发送验证代码，或者使用像 Google Authenticator 这样的外部应用程序。这种双因素身份验证（2FA）有助于提高安全性。即使有人知道你的密码，他们也无法在没有你的唯一令牌的情况下访问你的帐户。","身份验证authenticationvs-授权authorization#身份验证（Authentication）vs 授权（Authorization）":"在 Web 开发中，身份验证（Authentication）和授权（Authorization）扮演不同的角色：\n身份验证是确保用户是他们所说的那个人。你通过拥有的东西（如用户名和密码）证明你的身份。\n授权是下一步。一旦用户的身份确认，授权决定了他们被允许使用应用程序中的哪些部分。\n所以，身份验证检查你是谁，而授权确定你在应用程序中可以做什么或访问什么。","创建登录路由#创建登录路由":"首先，在你的应用程序中创建一个名为 /login 的新路由，并粘贴以下代码：\nimport AcmeLogo from '@/app/ui/acme-logo';\r\nimport LoginForm from '@/app/ui/login-form';\r\n \r\nexport default function LoginPage() {\r\n  return (\r\n    <main className=\"flex items-center justify-center md:h-screen\">\r\n      <div className=\"relative mx-auto flex w-full max-w-[400px] flex-col space-y-2.5 p-4 md:-mt-32\">\r\n        <div className=\"flex h-20 w-full items-end rounded-lg bg-blue-500 p-3 md:h-36\">\r\n          <div className=\"w-32 text-white md:w-36\">\r\n            <AcmeLogo />\r\n          </div>\r\n        </div>\r\n        <LoginForm />\r\n      </div>\r\n    </main>\r\n  );\r\n}\n你会注意到页面导入了 <LoginForm />，你将在本章后面更新这部分内容。","nextauthjs#NextAuth.js":"我们将使用 NextAuth.js 为你的应用程序添加身份验证。NextAuth.js 抽象了管理会话、登录和退出登录以及身份验证其他方面的许多复杂性。虽然你可以手动实现这些功能，但这个过程可能会耗时且容易出错。NextAuth.js 简化了这个过程，为 Next.js 应用程序提供了身份验证的统一解决方案。","设置-nextauthjs#设置 NextAuth.js":"在终端中运行以下命令安装 NextAuth.js：\nnpm install next-auth@beta\n在这里，你正在安装 NextAuth.js 的 beta 版本，该版本与 Next.js 14 兼容。接下来，为你的应用程序生成一个密钥。该密钥用于加密 cookie，确保用户会话的安全性。你可以通过在终端中运行以下命令来完成：\nopenssl rand -base64 32\n然后，在你的 .env 文件中，将生成的密钥添加到 AUTH_SECRET 变量中：\nAUTH_SECRET=your-secret-key\n为了使身份验证在生产环境中正常工作，你还需要在 Vercel 项目中更新环境变量。查看这篇关于如何在 Vercel 上添加环境变量的指南。","添加-pages-选项#添加 pages 选项":"在项目的根目录创建一个 auth.config.ts 文件，该文件导出一个 authConfig 对象。此对象将包含 NextAuth.js 的配置选项。目前，它将只包含 pages 选项：\nimport type { NextAuthConfig } from 'next-auth';\r\n \r\nexport const authConfig = {\r\n  pages: {\r\n    signIn: '/login',\r\n  },\r\n};\n你可以使用 pages 选项指定自定义登录、退出登录和错误页面的路由。这不是必需的，但通过将 signIn: '/login' 添加到我们的 pages 选项中，用户将被重定向到我们的自定义登录页面，而不是 NextAuth.js 默认页面。","使用-nextjs-middleware-保护路由#使用 Next.js Middleware 保护路由":"接下来，添加保护路由的逻辑。这将阻止用户在未登录的情况下访问 dashboard 页面。\nimport type { NextAuthConfig } from 'next-auth';\r\n \r\nexport const authConfig = {\r\n  pages: {\r\n    signIn: '/login',\r\n  },\r\n  callbacks: {\r\n    authorized({ auth, request: { nextUrl } }) {\r\n      const isLoggedIn = !!auth?.user;\r\n      const isOnDashboard = nextUrl.pathname.startsWith('/dashboard');\r\n      if (isOnDashboard) {\r\n        if (isLoggedIn) return true;\r\n        return false; // Redirect unauthenticated users to login page\r\n      } else if (isLoggedIn) {\r\n        return Response.redirect(new URL('/dashboard', nextUrl));\r\n      }\r\n      return true;\r\n    },\r\n  },\r\n  providers: [], // Add providers with an empty array for now\r\n} satisfies NextAuthConfig;\nauthorized 回调用于验证通过 Next.js 中间件访问页面的请求是否被授权。它在请求完成之前调用，并接收一个包含 auth 和 request 属性的对象。auth 属性包含用户的会话，request 属性包含传入的请求。providers 选项是一个数组，其中列出了不同的登录选项。目前，它是一个空数组，以满足 NextAuth 配置。你将在 “添加 Credentials provider” 部分中了解更多信息。接下来，你需要将 authConfig 对象导入到一个中间件文件中。在你的项目根目录中，创建一个名为 middleware.ts 的文件，并粘贴以下代码：\nimport NextAuth from 'next-auth';\r\nimport { authConfig } from './auth.config';\r\n \r\nexport default NextAuth(authConfig).auth;\r\n \r\nexport const config = {\r\n  // https://nextjs.org/docs/app/building-your-application/routing/middleware#matcher\r\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'],\r\n};\n在这里，你正在使用 authConfig 对象初始化 NextAuth.js，并导出 auth 属性。你还使用 Middleware 的 matcher 选项指定它应该在特定路径上运行。使用中间件执行此任务的优势在于，受保护的路由在中间件验证身份之前甚至不会开始渲染，从而增强了应用程序的安全性和性能。","密码哈希#密码哈希":"在将密码存储到数据库之前，对密码进行哈希处理是一种良好的做法。哈希将密码转换为一串固定长度的字符，看起来是随机的，即使用户的数据被曝露，也提供了一层安全性。在 seed.js 文件中，你使用了一个名为 bcrypt 的包来哈希用户的密码，然后将其存储在数据库中。在本章的后面，你将再次使用它来比较用户输入的密码是否与数据库中的密码匹配。但是，你需要为 bcrypt 包创建一个单独的文件。这是因为 bcrypt 依赖于 Next.js 中间件中不可用的 Node.js API。创建一个名为 auth.ts 的新文件，该文件包含你的 authConfig 对象：\nimport NextAuth from 'next-auth';\r\nimport { authConfig } from './auth.config';\r\n \r\nexport const { auth, signIn, signOut } = NextAuth({\r\n  ...authConfig,\r\n});","添加-credentials-provider#添加 Credentials provider":"接下来，你需要为 NextAuth.js 添加 providers 选项。providers 是一个数组，其中列出了不同的登录选项，如 Google 或 GitHub。在本课程中，我们将专注于仅使用 Credentials provider。Credentials provider 允许用户使用用户名和密码登录。\nimport NextAuth from 'next-auth';\r\nimport { authConfig } from './auth.config';\r\nimport Credentials from 'next-auth/providers/credentials';\r\n \r\nexport const { auth, signIn, signOut } = NextAuth({\r\n  ...authConfig,\r\n  providers: [Credentials({})],\r\n});\nGood to know: 尽管我们使用了 Credentials provider，但通常建议使用替代 providers，例如 OAuth 或 email providers。请查看 NextAuth.js 文档 以获取完整的选项列表。","添加登录功能#添加登录功能":"你可以使用 authorize 函数处理身份验证逻辑。类似于 Server Actions，你可以使用 zod 在检查用户是否存在于数据库之前验证电子邮件和密码：\nimport NextAuth from 'next-auth';\r\nimport { authConfig } from './auth.config';\r\nimport Credentials from 'next-auth/providers/credentials';\r\nimport { z } from 'zod';\r\n \r\nexport const { auth, signIn, signOut } = NextAuth({\r\n  ...authConfig,\r\n  providers: [\r\n    Credentials({\r\n      async authorize(credentials) {\r\n        const parsedCredentials = z\r\n          .object({ email: z.string().email(), password: z.string().min(6) })\r\n          .safeParse(credentials);\r\n      },\r\n    }),\r\n  ],\r\n});\n在验证凭据之后，创建一个新的 getUser 函数，该函数从数据库查询用户。\nimport NextAuth from 'next-auth';\r\nimport Credentials from 'next-auth/providers/credentials';\r\nimport { authConfig } from './auth.config';\r\nimport { z } from 'zod';\r\nimport { sql } from '@vercel/postgres'; // 这里需要注意！！！\r\nimport type { User } from '@/app/lib/definitions';\r\nimport bcrypt from 'bcrypt';\r\n \r\nasync function getUser(email: string): Promise<User | undefined> {\r\n  try {\r\n    const user = await sql<User>`SELECT * FROM users WHERE email=${email}`;\r\n    return user.rows[0];\r\n  } catch (error) {\r\n    console.error('Failed to fetch user:', error);\r\n    throw new Error('Failed to fetch user.');\r\n  }\r\n}\r\n \r\nexport const { auth, signIn, signOut } = NextAuth({\r\n  ...authConfig,\r\n  providers: [\r\n    Credentials({\r\n      async authorize(credentials) {\r\n        const parsedCredentials = z\r\n          .object({ email: z.string().email(), password: z.string().min(6) })\r\n          .safeParse(credentials);\r\n \r\n        if (parsedCredentials.success) {\r\n          const { email, password } = parsedCredentials.data;\r\n          const user = await getUser(email);\r\n          if (!user) return null;\r\n        }\r\n \r\n        return null;\r\n      },\r\n    }),\r\n  ],\r\n});\n译者注：因为 Vercel Postgres 搭配本地数据库还存在一些问题，在 nextjs-learn-example 示例中，我使用了一种 hack 的方式来处理，如果您在本地开发是按照我的 hack 方式，请替换 import { sql } from '@vercel/postgres'; 为 import { sql } from './sql-hack'; 详情参见 https://qufei1993.github.io/nextjs-learn-cn/chapter17\n然后，调用 bcrypt.compare 检查密码是否匹配：\nimport NextAuth from 'next-auth';\r\nimport Credentials from 'next-auth/providers/credentials';\r\nimport { authConfig } from './auth.config';\r\nimport { sql } from '@vercel/postgres'; // 这里需要注意！！！\r\nimport { z } from 'zod';\r\nimport type { User } from '@/app/lib/definitions';\r\nimport bcrypt from 'bcrypt';\r\n \r\n// ...\r\n \r\nexport const { auth, signIn, signOut } = NextAuth({\r\n  ...authConfig,\r\n  providers: [\r\n    Credentials({\r\n      async authorize(credentials) {\r\n        // ...\r\n \r\n        if (parsedCredentials.success) {\r\n          const { email, password } = parsedCredentials.data;\r\n          const user = await getUser(email);\r\n          if (!user) return null;\r\n          const passwordsMatch = await bcrypt.compare(password, user.password);\r\n \r\n          if (passwordsMatch) return user;\r\n        }\r\n \r\n        console.log('Invalid credentials');\r\n        return null;\r\n      },\r\n    }),\r\n  ],\r\n});\n最后，如果密码匹配返回 user，否则返回 null 以防止用户登录。","更新登录-form#更新登录 form":"现在你需要将身份验证逻辑与登录 form 连接起来。在你的 actions.ts 文件中，创建一个名为 authenticate 的新 action。此 action 应该从 auth.ts 导入 signIn 函数：\nimport { signIn } from '@/auth';\r\nimport { AuthError } from 'next-auth';\r\n \r\n// ...\r\n \r\nexport async function authenticate(\r\n  prevState: string | undefined,\r\n  formData: FormData,\r\n) {\r\n  try {\r\n    await signIn('credentials', formData);\r\n  } catch (error) {\r\n    if (error instanceof AuthError) {\r\n      switch (error.type) {\r\n        case 'CredentialsSignin':\r\n          return 'Invalid credentials.';\r\n        default:\r\n          return 'Something went wrong.';\r\n      }\r\n    }\r\n    throw error;\r\n  }\r\n}\n如果出现 'CredentialsSignin' 错误，你希望显示一个合适的错误消息。你可以在文档中了解有关 NextAuth.js 错误的信息。最后，在你的 login-form.tsx 组件中，你可以使用 React 的 useFormState 调用服务器操作并处理 form 错误，并使用 useFormStatus 处理 form 的 pending 状态：\n'use client';\r\n \r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport {\r\n  AtSymbolIcon,\r\n  KeyIcon,\r\n  ExclamationCircleIcon,\r\n} from '@heroicons/react/24/outline';\r\nimport { ArrowRightIcon } from '@heroicons/react/20/solid';\r\nimport { Button } from '@/app/ui/button';\r\nimport { useFormState, useFormStatus } from 'react-dom';\r\nimport { authenticate } from '@/app/lib/actions';\r\n \r\nexport default function LoginForm() {\r\n  const [errorMessage, dispatch] = useFormState(authenticate, undefined);\r\n \r\n  return (\r\n    <form action={dispatch} className=\"space-y-3\">\r\n      <div className=\"flex-1 rounded-lg bg-gray-50 px-6 pb-4 pt-8\">\r\n        <h1 className={`${lusitana.className} mb-3 text-2xl`}>\r\n          Please log in to continue.\r\n        </h1>\r\n        <div className=\"w-full\">\r\n          <div>\r\n            <label\r\n              className=\"mb-3 mt-5 block text-xs font-medium text-gray-900\"\r\n              htmlFor=\"email\"\r\n            >\r\n              Email\r\n            </label>\r\n            <div className=\"relative\">\r\n              <input\r\n                className=\"peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500\"\r\n                id=\"email\"\r\n                type=\"email\"\r\n                name=\"email\"\r\n                placeholder=\"Enter your email address\"\r\n                required\r\n              />\r\n              <AtSymbolIcon className=\"pointer-events-none absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500 peer-focus:text-gray-900\" />\r\n            </div>\r\n          </div>\r\n          <div className=\"mt-4\">\r\n            <label\r\n              className=\"mb-3 mt-5 block text-xs font-medium text-gray-900\"\r\n              htmlFor=\"password\"\r\n            >\r\n              Password\r\n            </label>\r\n            <div className=\"relative\">\r\n              <input\r\n                className=\"peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500\"\r\n                id=\"password\"\r\n                type=\"password\"\r\n                name=\"password\"\r\n                placeholder=\"Enter password\"\r\n                required\r\n                minLength={6}\r\n              />\r\n              <KeyIcon className=\"pointer-events-none absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500 peer-focus:text-gray-900\" />\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <LoginButton />\r\n        <div\r\n          className=\"flex h-8 items-end space-x-1\"\r\n          aria-live=\"polite\"\r\n          aria-atomic=\"true\"\r\n        >\r\n          {errorMessage && (\r\n            <>\r\n              <ExclamationCircleIcon className=\"h-5 w-5 text-red-500\" />\r\n              <p className=\"text-sm text-red-500\">{errorMessage}</p>\r\n            </>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </form>\r\n  );\r\n}\r\n \r\nfunction LoginButton() {\r\n  const { pending } = useFormStatus();\r\n \r\n  return (\r\n    <Button className=\"mt-4 w-full\" aria-disabled={pending}>\r\n      Log in <ArrowRightIcon className=\"ml-auto h-5 w-5 text-gray-50\" />\r\n    </Button>\r\n  );\r\n}","添加注销功能#添加注销功能":"要将注销功能添加到 <SideNav />，在你的 <form> 元素中调用来自 auth.ts 的 signOut 函数：\nimport Link from 'next/link';\r\nimport NavLinks from '@/app/ui/dashboard/nav-links';\r\nimport AcmeLogo from '@/app/ui/acme-logo';\r\nimport { PowerIcon } from '@heroicons/react/24/outline';\r\nimport { signOut } from '@/auth';\r\n \r\nexport default function SideNav() {\r\n  return (\r\n    <div className=\"flex h-full flex-col px-3 py-4 md:px-2\">\r\n      // ...\r\n      <div className=\"flex grow flex-row justify-between space-x-2 md:flex-col md:space-x-0 md:space-y-2\">\r\n        <NavLinks />\r\n        <div className=\"hidden h-auto w-full grow rounded-md bg-gray-50 md:block\"></div>\r\n        <form\r\n          action={async () => {\r\n            'use server';\r\n            await signOut();\r\n          }}\r\n        >\r\n          <button className=\"flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3\">\r\n            <PowerIcon className=\"w-6\" />\r\n            <div className=\"hidden md:block\">Sign Out</div>\r\n          </button>\r\n        </form>\r\n      </div>\r\n    </div>\r\n  );\r\n}","试试看#试试看":"现在，试试看。你应该能够使用以下凭据登录和退出你的应用程序：Email: user@nextmail.com\r\nPassword: 123456"}},"/chapter3":{"title":"优化字体和图片","data":{"":"在上一章中，您学习了如何为 Next.js 应用程序添加样式。让我们继续通过添加自定义字体和主页图片来完善您的主页。以下是本章中将涵盖的主题：\n如何使用 next/font 添加自定义字体。\n如何使用 next/image 添加图片。\nNext.js 中如何优化字体和图片。","为什么要优化字体#为什么要优化字体？":"字体在网站设计中起着重要作用，但在项目中使用自定义字体可能会影响性能，特别是当需要获取和加载字体文件时。累积布局移位（Cumulative Layout Shift）是 Google 用于评估网站性能和用户体验的度量标准。对于字体而言，布局移位发生在浏览器最初使用备用或系统字体呈现文本，然后在加载完自定义字体后进行替换。这种替换可能导致文本大小、间距或布局发生变化，从而使其周围的元素发生移位。Next.js 在您使用 next/font 模块时会自动优化应用程序中的字体。它在构建时下载字体文件并将其托管在您的其他静态资产之中。这意味着当用户访问您的应用程序时，不会有额外的字体网络请求，从而不会影响性能。","添加主要字体#添加主要字体":"让我们向您的应用程序添加一个自定义的 Google 字体，看看它是如何工作的！在 /app/ui 文件夹中，创建一个名为 fonts.ts 的新文件。您将使用此文件来保存将在整个应用程序中使用的字体。从 next/font/google 模块导入 Inter 字体 - 这将是您的主要字体。然后，指定您想要加载的子集。在这种情况下，是 'latin'：\nimport { Inter } from 'next/font/google';\r\n \r\nexport const inter = Inter({ subsets: ['latin'] });\n最后，在 /app/layout.tsx 中的 <body> 元素中添加字体：\nimport '@/app/ui/global.css';\r\nimport { inter } from '@/app/ui/fonts';\r\n \r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode;\r\n}) {\r\n  return (\r\n    <html lang=\"en\">\r\n      <body className={`${inter.className} antialiased`}>{children}</body>\r\n    </html>\r\n  );\r\n}\n通过将 Inter 添加到 <body> 元素中，该字体将应用于整个应用程序。在这里，您还添加了 Tailwind 的 antialiased 类，该类可使字体更加平滑。使用这个类并不是必需的，但它会增添一些美感。在浏览器中导航到开发者工具，选择 body 元素。您应该会在样式下看到 Inter 和 Inter_Fallback 已经被应用。","实践添加次要字体#实践：添加次要字体":"您还可以将字体添加到应用程序的特定元素。现在轮到您了！在您的 fonts.ts 文件中，导入一个名为 Lusitana 的次要字体，并将其传递给 /app/page.tsx 文件中的 <p> 元素。除了像之前一样指定一个子集，您还需要指定字体的粗细。准备好后，展开下面的代码片段以查看解决方案。\n提示：\n如果您不确定要传递给字体的权重选项，请在代码编辑器中检查 TypeScript 错误。\n访问 Google Fonts 网站并搜索 Lusitana，查看可用的选项。\n查看添加多个字体和所有选项的完整列表的文档。\n点击展开/折叠\nimport { Inter, Lusitana } from 'next/font/google';\r\n\r\nexport const inter = Inter({ subsets: ['latin'] });\r\n\r\nexport const lusitana = Lusitana({\r\n  weight: ['400', '700'],\r\n  subsets: ['latin'],\r\n});\nimport AcmeLogo from '@/app/ui/acme-logo';\r\nimport { ArrowRightIcon } from '@heroicons/react/24/outline';\r\nimport { lusitana } from '@/app/ui/fonts';\r\n\r\nexport default function Page() {\r\n  return (\r\n    // ...\r\n    <p\r\n      className={`${lusitana.className} text-xl text-gray-800 md:text-3xl md:leading-normal`}\r\n    >\r\n      <strong>Welcome to Acme.</strong> This is the example for the{' '}\r\n      <a href=\"https://nextjs.org/learn/\" className=\"text-blue-500\">\r\n        Learn Next.js Course\r\n      </a>\r\n      , brought to you by Vercel.\r\n    </p>\r\n    // ...\r\n  );\r\n}\n最后，<AcmeLogo /> 组件也使用了 Lusitana 字体。之前被注释掉是为了防止错误，现在你可以取消注释它：\n// ...\r\n \r\nexport default function Page() {\r\n  return (\r\n    <main className=\"flex min-h-screen flex-col p-6\">\r\n      <div className=\"flex h-20 shrink-0 items-end rounded-lg bg-blue-500 p-4 md:h-52\">\r\n        <AcmeLogo />\r\n        {/* ... */}\r\n      </div>\r\n    </main>\r\n  );\r\n}\n好的，您已将两种自定义字体添加到应用程序！接下来，让我们向主页添加一个主图像。","为什么要优化图片#为什么要优化图片？":"Next.js 可以在顶层 /public 文件夹下提供静态资源，如图片。/public 中的文件可以在你的应用程序中引用。在常规的 HTML 中，你可以如下添加图片：\n<img\r\n  src=\"/hero.png\"\r\n  alt=\"Screenshots of the dashboard project showing desktop version\"\r\n/>\n然而，这意味着你必须手动：\n确保你的图片在不同屏幕尺寸上具有响应性。\n为不同设备指定图片大小。\n防止图片加载时的布局变化。\n对用户视口外的图片进行懒加载。\n图片优化是 Web 开发中一个庞大的主题，可以被认为是一门专业领域。与手动实现这些优化相比，你可以使用 next/image 组件来自动优化你的图片。","image-组件#<Image> 组件":"<Image> 组件是 HTML <img> 标签的扩展，具有自动图像优化功能，包括：\n图片加载时自动防止布局移位。\n调整图像大小，避免向视口较小的设备传送大图像。\n默认情况下懒加载图像（图像在进入视口时加载）。\n在浏览器支持的情况下，以现代格式提供图像，如 WebP 和 AVIF。","添加桌面版主图#添加桌面版主图":"让我们使用 <Image> 组件。如果你查看 /public 文件夹，你会看到有两张图片：hero-desktop.png 和 hero-mobile.png。这两张图片完全不同，它们将根据用户设备是桌面还是移动端而显示不同的图片。在你的 /app/page.tsx 文件中，从 next/image 导入该组件。然后，在注释下方添加图片：\nimport AcmeLogo from '@/app/ui/acme-logo';\r\nimport { ArrowRightIcon } from '@heroicons/react/24/outline';\r\nimport Link from 'next/link';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport Image from 'next/image';\r\n\r\nexport default function Page() {\r\n  return (\r\n    // ...\r\n    <div className=\"flex items-center justify-center p-6 md:w-3/5 md:px-28 md:py-12\">\r\n      {/* Add Hero Images Here */}\r\n      <Image\r\n        src=\"/hero-desktop.png\"\r\n        width={1000}\r\n        height={760}\r\n        className=\"hidden md:block\"\r\n        alt=\"Screenshots of the dashboard project showing desktop version\"\r\n      />\r\n    </div>\r\n    //...\r\n  );\r\n}\n在这里，你将宽度设置为 1000 像素，高度设置为 760 像素。设置图像的宽度和高度以避免布局变化是一种良好的实践，这些应该是与源图像相同的纵横比。你还会注意到使用了 hidden 类，这会在移动屏幕上从 DOM 中移除图片，而 md:block 会在桌面屏幕上显示图片。你的主页现在应该是这个样子：","实践添加移动端主页图片#实践：添加移动端主页图片":"现在轮到你了！在刚刚添加的图片下面，再添加另一个用于 hero-mobile.png 的 <Image> 组件。这张图片的宽度应该是 560 像素，高度是 620 像素。它应该在移动屏幕上显示，在桌面上隐藏 - 你可以使用开发工具检查桌面和移动图片是否正确切换。当你准备好时，展开下面的代码片段查看解决方案。\nimport AcmeLogo from '@/app/ui/acme-logo';\r\nimport { ArrowRightIcon } from '@heroicons/react/24/outline';\r\nimport Link from 'next/link';\r\nimport { lusitana } from '@/app/ui/fonts';\r\nimport Image from 'next/image';\r\n \r\nexport default function Page() {\r\n  return (\r\n    // ...\r\n    <div className=\"flex items-center justify-center p-6 md:w-3/5 md:px-28 md:py-12\">\r\n      {/* Add Hero Images Here */}\r\n      <Image\r\n        src=\"/hero-desktop.png\"\r\n        width={1000}\r\n        height={760}\r\n        className=\"hidden md:block\"\r\n        alt=\"Screenshots of the dashboard project showing desktop version\"\r\n      />\r\n      <Image\r\n        src=\"/hero-mobile.png\"\r\n        width={560}\r\n        height={620}\r\n        className=\"block md:hidden\"\r\n        alt=\"Screenshot of the dashboard project showing mobile version\"\r\n      />\r\n    </div>\r\n    //...\r\n  );\r\n}\n太好了！你的主页现在已经使用了自定义字体和主页图片。","推荐阅读#推荐阅读":"关于这些主题，还有很多可以学习的内容，包括优化远程图像和使用本地字体文件。如果您想深入了解字体和图像，请参阅：\n图像优化文档\n字体优化文档\n使用图像改善 Web 性能 (MDN)\nWeb 字体 (MDN)"}},"/chapter17":{"title":"Vercel Postgres 搭配本地数据库","data":{"":"在 Learn Next.js 教程中数据库链接采用的是 Vercel Postgres，本地开发会遇到一些网络问题，导致体验并不是很好。\r\n因此，在本地开发时我期望能将本地数据库与 Vercel Postgres 一起使用，但目前支持的并不是很好。才有了下面这篇文章介绍。","安装-postgres-数据库#安装 Postgres 数据库":"选择你熟悉的方式搭建本地数据库，以下使用 Docker 命令：\ndocker run --name myPostgresDb -p 5432:5432 -e POSTGRES_USER=postgresUser -e POSTGRES_PASSWORD=postgresPW -e POSTGRES_DB=postgresDB -d postgres","遇到的问题#遇到的问题":"替换 .env 中的数据库配置为本地数据库信息：\nPOSTGRES_URL=\"postgres://postgresUser:postgresPW@127.0.0.1:5432/postgresDB\"\r\nPOSTGRES_PRISMA_URL=\"postgres://postgresUser:postgresPW@127.0.0.1:5432/postgresDB?pgbouncer=true&connect_timeout=15\"\r\nPOSTGRES_URL_NON_POOLING=\"postgres://postgresUser:postgresPW@127.0.0.1:5432/postgresDB\"\r\nPOSTGRES_USER=\"postgresUser\"\r\nPOSTGRES_HOST=\"127.0.0.1\"\r\nPOSTGRES_PASSWORD=\"postgresPW\"\r\nPOSTGRES_DATABASE=\"postgresDB\"\n执行 Examples 的 yarn seed 命令，起初会得到如下错误：\nAn error occurred while attempting to seed the database: VercelPostgresError: VercelPostgresError - 'invalid_connection_string': This connection string is meant to be used with a direct connection. Make sure to use a pooled connection string or try `createClient()` instead.\n这是因为 Vercel 对 URL 有一些硬编码的校验，这一块很难饶过，详情参见 ISSUE#123。但根据上面的错误提示，可以导入 createClient() 方法进行尝试，于是修改代码 scripts/seed.js 如下所示：\nconst { db, createClient } = require('@vercel/postgres');\r\n\r\nasync function main() {\r\n  const client = await createClient({ connectionString: process.env.POSTGRES_URL })\r\n  await client.connect();\r\n  // ...\r\n}\n尝试更改之后又报错了，这报错信息让人也很不理解，就本地连接个数据库，为什么还需要链接 443 端口？\n  Error: connect ECONNREFUSED 127.0.0.1:443\r\n  at TCPConnectWrap.afterConnect [as oncomplete] (node:net:1570:16) Emitted 'error' event on WebSocket instance at:\r\n  at ClientRequest.emit (node:events:511:28)\r\n  at TLSSocket.socketErrorListener (node:_http_client:495:9)\r\n  at TLSSocket.emit (node:events:511:28)\r\n  at emitErrorNT (node:internal/streams/destroy:151:8)\r\n  at emitErrorCloseNT (node:internal/streams/destroy:116:3)\r\n  at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {\r\n    errno: -61,\r\n    code: 'ECONNREFUSED',\r\n    syscall: 'connect',\r\n    address: '127.0.0.1',\r\n    port: 443\r\n  }\n这是因为在底层，Vercel Postgres 连接器使用 WebSocket 连接。createClient() 返回的 client 实例是来自 node-postgres\r\n模块，但是 PostgreSQL 本身并不支持 WebSocket。除了运行本地数据库还要运行一个代理，这里有一篇文章介绍 https://gal.hagever.com/posts/running-vercel-postgres-locally 。\r\n但这种方式对本地开发不是太友好，没有一个清晰的步骤来介绍怎么使用。在这些问题上浪费了不少时间。最后，决定采用 pg 库，按照 Learn Next.js 教程的使用示例，做了一些修改。","seed-脚本中使用本地数据库-postgres#seed 脚本中使用本地数据库 Postgres":"安装 pg 模块：yarn add pg。创建 /scripts/pg-local.js 文件。注意：因为 Vercel Postgres 并没有提供 \"sql``\" 这样模版字符串的方式来根据 SQL 内容查询数据，因此，我们这里也需要做些修改，来适配 Learn Next.js 教程示例中的写法。\nconst { Client } = require('pg');\r\n\r\nconst client = new Client(process.env.POSTGRES_URL || \"postgres://postgresUser:postgresPW@127.0.0.1:5432/postgresDB\");\r\n\r\nexports.getClient = async () => {\r\n   if (!client._connected) {\r\n      await client.connect();\r\n   }\r\n\r\n   // 适配这样的语句查询数据：client.sql`SHOW TIME ZONE;`\r\n   client.sql = async (strings, ...values) => {\r\n      if (!strings) {\r\n         throw new ('sql is required')\r\n      }\r\n      const [query, params] = sqlTemplate(strings, ...values)\r\n      const res = await client.query(query, params);\r\n      return res;\r\n   }\r\n\r\n   return client;\r\n}\r\n\r\nfunction sqlTemplate(strings, ...values) {\r\n   if (!isTemplateStringsArray(strings) || !Array.isArray(values)) {\r\n     throw new Error(\r\n       'incorrect_tagged_template_call',\r\n       \"It looks like you tried to call `sql` as a function. Make sure to use it as a tagged template.\\n\\tExample: sql`SELECT * FROM users`, not sql('SELECT * FROM users')\",\r\n     );\r\n   }\r\n \r\n   let result = strings[0] ?? '';\r\n \r\n   for (let i = 1; i < strings.length; i++) {\r\n     result += `$${i}${strings[i] ?? ''}`;\r\n   }\r\n \r\n   return [result, values];\r\n}\r\n \r\nfunction isTemplateStringsArray(strings) {\r\n   return (\r\n      Array.isArray(strings) && 'raw' in strings && Array.isArray(strings.raw)\r\n   );\r\n}\r\n\r\n// (async () => {\r\n//    // Test script\r\n//    try {\r\n//       const clientInstance = await exports.getClient(); \r\n//       const res = await clientInstance.sql`SHOW TIME ZONE;`\r\n//       console.log(res.rows[0].TimeZone) // 'Etc/UTC'\r\n//    } catch (err) {\r\n//       console.error(err);\r\n//    } finally {\r\n//       await client.end()\r\n//    }\r\n// })();\n在 seed 脚本文件 /scripts/seed.js 中新增环境变量 LOCAL_VERCEL_POSTGRES 判断逻辑，如果是本地 postgres 数据库\r\n调用我们刚写的 getClient() 方法获取 client 实例，否则还是使用 Vercel Postgres 提供的 client 实例。\nconst { db } = require('@vercel/postgres');\r\nconst { getClient } = require('./pg-local');\r\n\r\n// ...\r\n\r\nasync function main() {\r\n  const client = process.env.LOCAL_VERCEL_POSTGRES ? await getClient() : await db.connect();\r\n\r\n  await seedUsers(client);\r\n  await seedCustomers(client);\r\n  await seedInvoices(client);\r\n  await seedRevenue(client);\r\n\r\n  await client.end();\r\n}","业务代码中使用本地数据库-postgres#业务代码中使用本地数据库 Postgres":"与 seed 脚本不同，Learn Next.js 教程中的其余代码都采用的 TypeScript 写法，因此我们还需要在写一个 TS 版本。这里要使用的链接池，这里使用 pg 模块的 Pool 类创建链接池实例，详情参见 Pooling创建 /app/lib/pg-local.ts 文件。\nimport { Pool } from 'pg';\r\nimport type {\r\n  QueryResult,\r\n  QueryResultRow,\r\n} from '@neondatabase/serverless';\r\n\r\nconst connectionString = process.env.POSTGRES_URL;\r\n\r\nconst pool = new Pool({\r\n  connectionString,\r\n})\r\n\r\nexport async function sql<O extends QueryResultRow>(\r\n  strings: TemplateStringsArray,\r\n  ...values: Primitive[]\r\n): Promise<QueryResult<O>> {\r\n  const [query, params] = sqlTemplate(strings, ...values);\r\n\r\n  // @ts-ignore\r\n  const res = await pool.query(query, params);\r\n\r\n  // @ts-ignore\r\n  return res as unknown as Promise<QueryResult<O>>;\r\n}\r\n\r\nexport type Primitive = string | number | boolean | undefined | null;\r\n\r\nexport function sqlTemplate(\r\n  strings: TemplateStringsArray,\r\n  ...values: Primitive[]\r\n): [string, Primitive[]] {\r\n  if (!isTemplateStringsArray(strings) || !Array.isArray(values)) {\r\n    throw new Error(\"It looks like you tried to call `sql` as a function. Make sure to use it as a tagged template.\\n\\tExample: sql`SELECT * FROM users`, not sql('SELECT * FROM users')\");\r\n  }\r\n\r\n  let result = strings[0] ?? '';\r\n\r\n  for (let i = 1; i < strings.length; i++) {\r\n    result += `$${i}${strings[i] ?? ''}`;\r\n  }\r\n\r\n  return [result, values];\r\n}\r\n\r\nfunction isTemplateStringsArray(\r\n  strings: unknown,\r\n): strings is TemplateStringsArray {\r\n  return (\r\n    Array.isArray(strings) && 'raw' in strings && Array.isArray(strings.raw)\r\n  );\r\n}\n创建 /app/lib/sql-hack.ts 文件。根据环境变量做区分，本地开发时使用本地的 postgres 数据库。\nimport { sql as vercelSql } from '@vercel/postgres';\r\nimport { sql as pgLocalSql } from './pg-local';\r\n\r\nexport const sql = process.env.LOCAL_VERCEL_POSTGRES ? pgLocalSql : vercelSql\n修改 /app/lib/data.ts 文件。\nimport { sql } from './sql-hack';\n请注意：以上是一个 hack 的解决方案，只适用解决本教程示例中遇到的问题。如果选用 Next.js 做开发时，推荐关注一些 ORM 框架，例如 Prisma 还是很好用的，这不是这篇教程的重点，这里不会展开介绍。"}},"/chapter8":{"title":"静态和动态渲染","data":{"":"在上一章中，您为 Dashboard 概述页面获取了数据。但是，我们简要讨论了当前设置的两个局限性：\n数据请求正在创造一个无意的瀑布。\nDashboard 是静态的，因此任何数据更新都不会反映在您的应用程序上。\n以下是本章中将涵盖的主题：\n什么是静态渲染，以及它如何提高应用程序的性能。\n什么是动态渲染以及何时使用它。\n使 Dashboard 动态化的不同方法。\n模拟一个缓慢的数据获取，看看会发生什么。","什么是静态渲染#什么是静态渲染？":"使用静态渲染，数据获取和渲染在构建时（部署时）或重新验证期间在服务器上进行。然后，结果可以在内容分发网络（CDN）中分发和缓存。每当用户访问你的应用程序时，缓存的结果都会被提供。静态渲染有几个好处：\n更快的网站 - 预渲染的内容可以被缓存和全球分布。这确保了世界各地的用户可以更快、更可靠地访问您的网站内容。\n减少服务器负载 - 由于内容被缓存，您的服务器不必为每个用户请求动态生成内容。\n搜索引擎优化 - 预渲染内容更容易被搜索引擎爬虫索引，因为当页面加载时，内容已经可用。这可以提高搜索引擎排名。\n静态渲染对于没有数据或跨用户共享数据的 UI（如静态博客文章或产品页面）非常有用。它可能不适合具有定期更新的个性化数据的 Dashboard。与静态渲染相反的是动态渲染。","什么是动态渲染#什么是动态渲染？":"通过动态渲染，内容在请求时（当用户访问页面时）在服务器上为每个用户呈现。动态渲染有几个好处：\n实时数据 - 动态渲染允许您的应用程序显示实时或频繁更新的数据。这对于数据经常变化的应用程序来说是理想的。\n用户特定内容 - 提供个性化内容（如 Dashboard 或用户配置文件）并根据用户交互更新数据更容易。\n请求时间信息 - 动态渲染允许您访问只能在请求时知道的信息，如 Cookie 或 URL 搜索参数。","使-dashboard-动态化#使 Dashboard 动态化":"默认情况下，@vercel/postgresql 不设置自己的缓存语义。这允许框架设置自己的静态和动态行为。您可以在服务器组件或数据获取函数中使用名为 unstable_noStore 的 Next.js API 来选择退出静态呈现。让我们添加这个。在你的 data.ts 中，从 next/cache 导入 unstable_noStore，并在数据获取函数的顶部调用它：\n// ...\r\nimport { unstable_noStore as noStore } from 'next/cache';\r\n \r\nexport async function fetchRevenue() {\r\n  // Add noStore() here to prevent the response from being cached.\r\n  // This is equivalent to in fetch(..., {cache: 'no-store'}).\r\n  noStore();\r\n \r\n  // ...\r\n}\r\n \r\nexport async function fetchLatestInvoices() {\r\n  noStore();\r\n  // ...\r\n}\r\n \r\nexport async function fetchCardData() {\r\n  noStore();\r\n  // ...\r\n}\r\n \r\nexport async function fetchFilteredInvoices(\r\n  query: string,\r\n  currentPage: number,\r\n) {\r\n  noStore();\r\n  // ...\r\n}\r\n \r\nexport async function fetchInvoicesPages(query: string) {\r\n  noStore();\r\n  // ...\r\n}\r\n \r\nexport async function fetchFilteredCustomers(query: string) {\r\n  noStore();\r\n  // ...\r\n}\r\n \r\nexport async function fetchInvoiceById(query: string) {\r\n  noStore();\r\n  // ...\r\n}\n注意：unstable_noStore 是一个实验性的 API，可能在将来发生变化。如果您更喜欢在自己的项目中使用稳定的 API，您也可以使用 Segment 配置选项 export const dynamic = \"force-dynamic\"。","模拟慢速数据获取#模拟慢速数据获取":"使 Dashboard 动态化是迈出的良好第一步。然而... 还有一个我们在上一章提到的问题。如果一个数据请求比其他所有请求都慢，会发生什么？让我们模拟一次慢速数据获取。在您的 data.ts 文件中，取消注释 fetchRevenue() 函数内部的 console.log 和 setTimeout：\nexport async function fetchRevenue() {\r\n  try {\r\n    // 为演示目的，我们人为延迟响应。\r\n    // 在生产中请勿这样做 :)\r\n    console.log('Fetching revenue data...');\r\n    await new Promise((resolve) => setTimeout(resolve, 3000));\r\n \r\n    const data = await sql<Revenue>`SELECT * FROM revenue`;\r\n \r\n    console.log('Data fetch completed after 3 seconds.');\r\n \r\n    return data.rows;\r\n  } catch (error) {\r\n    console.error('Database Error:', error);\r\n    throw new Error('Failed to fetch revenue data.');\r\n  }\r\n}\n现在在新标签页中打开 http://localhost:3000/dashboard/， 注意页面加载所需的时间较长。在终端中，您还应该看到以下消息：\nFetching revenue data...\r\nData fetch completed after 3 seconds.\n在这里，您添加了一个人为的 3 秒延迟，以模拟慢速数据获取。结果是在获取数据时整个页面被阻塞。这引出了开发者必须解决的一个常见挑战：使用动态渲染，您的应用程序速度只有在最慢的数据获取完成时才能达到。"}}}